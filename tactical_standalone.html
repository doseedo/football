<!DOCTYPE html>
<html>
<head>
    <title>Football Tactical Analysis - Standalone</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }
        .header { text-align: center; margin-bottom: 20px; }
        h1 { color: #4ecca3; font-size: 28px; margin-bottom: 5px; }
        .subtitle { color: #888; font-size: 14px; }
        .main-container {
            display: flex; gap: 20px; max-width: 1600px; margin: 0 auto;
            flex-wrap: wrap; justify-content: center;
        }
        .pitch-panel {
            background: #16213e; border-radius: 12px; padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .side-panel {
            background: #16213e; border-radius: 12px; padding: 20px;
            width: 350px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        #pitch { background: #2d5a27; border: 3px solid #fff; border-radius: 5px; cursor: crosshair; }
        .tabs { display: flex; gap: 5px; margin-bottom: 15px; }
        .tab {
            flex: 1; padding: 10px; background: #0f3460; border: none;
            border-radius: 5px; color: #888; cursor: pointer; font-size: 13px;
        }
        .tab.active { background: #4ecca3; color: #1a1a2e; font-weight: bold; }
        .tab:hover:not(.active) { background: #1a4a7a; color: #fff; }
        .controls { display: flex; gap: 8px; margin: 15px 0; flex-wrap: wrap; justify-content: center; }
        button {
            background: #4ecca3; color: #1a1a2e; border: none; padding: 10px 16px;
            border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 13px;
        }
        button:hover { background: #3db892; }
        button:disabled { background: #444; color: #888; cursor: not-allowed; }
        button.secondary { background: #0f3460; color: #4ecca3; }
        button.danger { background: #e94560; color: #fff; }
        .info-section { margin: 15px 0; padding: 12px; background: #0f3460; border-radius: 8px; }
        .info-section h4 { color: #4ecca3; margin-bottom: 10px; font-size: 14px; }
        .info-row { display: flex; justify-content: space-between; margin: 6px 0; font-size: 13px; }
        .info-label { color: #888; }
        .info-value { color: #fff; font-weight: 500; }
        .action-list { max-height: 200px; overflow-y: auto; }
        .action-item {
            padding: 8px 10px; margin: 5px 0; background: #1a1a2e;
            border-radius: 5px; cursor: pointer; font-size: 12px;
        }
        .action-item:hover { background: #2a2a4e; }
        .action-item.selected { border-left: 3px solid #4ecca3; }
        .action-type { color: #4ecca3; font-weight: bold; text-transform: uppercase; }
        .action-value { float: right; color: #f1c40f; }
        .legend { display: flex; gap: 15px; margin-top: 15px; font-size: 12px; justify-content: center; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-dot { width: 14px; height: 14px; border-radius: 50%; }
        .slider-container { display: flex; align-items: center; gap: 10px; margin: 10px 0; }
        .slider-container label { font-size: 12px; color: #888; min-width: 60px; }
        input[type="range"] { flex: 1; height: 6px; background: #0f3460; border-radius: 3px; }
        .result-success { color: #4ecca3; }
        .result-fail { color: #e94560; }
        .result-goal { color: #f1c40f; }
        .editor-tools { display: flex; gap: 5px; margin: 10px 0; flex-wrap: wrap; }
        .tool-btn { padding: 8px 12px; font-size: 12px; border-radius: 5px; }
        .tool-btn.active { background: #4ecca3; color: #1a1a2e; }
        .step-counter { font-size: 24px; color: #4ecca3; text-align: center; margin: 10px 0; }
        .progress-bar { height: 4px; background: #0f3460; border-radius: 2px; margin: 10px 0; overflow: hidden; }
        .progress-fill { height: 100%; background: #4ecca3; transition: width 0.3s; }
        .help-text { font-size: 11px; color: #666; margin-top: 5px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Football Tactical Analysis</h1>
        <p class="subtitle">Standalone Decision Engine - Runs in Browser</p>
    </div>

    <div class="main-container">
        <div class="pitch-panel">
            <canvas id="pitch" width="750" height="480"></canvas>
            <div class="legend">
                <div class="legend-item"><div class="legend-dot" style="background: #3498db;"></div><span>Attackers</span></div>
                <div class="legend-item"><div class="legend-dot" style="background: #e74c3c;"></div><span>Defenders</span></div>
                <div class="legend-item"><div class="legend-dot" style="background: #f1c40f;"></div><span>Ball</span></div>
            </div>
        </div>

        <div class="side-panel">
            <div class="tabs">
                <button class="tab active" onclick="switchTab('simulation')">Simulation</button>
                <button class="tab" onclick="switchTab('editor')">Editor</button>
                <button class="tab" onclick="switchTab('analysis')">Analysis</button>
            </div>

            <div id="simulation-tab" class="tab-content">
                <div class="step-counter">Step <span id="stepNum">0</span> / <span id="totalSteps">0</span></div>
                <div class="progress-bar"><div class="progress-fill" id="progressBar" style="width: 0%"></div></div>
                <div class="controls">
                    <button onclick="resetSim()">Reset</button>
                    <button onclick="stepBack()" id="backBtn">Back</button>
                    <button onclick="togglePlay()" id="playBtn">Play</button>
                    <button onclick="stepForward()" id="fwdBtn">Next</button>
                </div>
                <div class="slider-container">
                    <label>Speed</label>
                    <input type="range" id="speed" min="200" max="2000" value="800" onchange="updateSpeed()">
                </div>
                <div class="info-section">
                    <h4>Current State</h4>
                    <div class="info-row"><span class="info-label">Ball Carrier</span><span class="info-value" id="carrier">-</span></div>
                    <div class="info-row"><span class="info-label">Ball Position</span><span class="info-value" id="ballPos">-</span></div>
                </div>
                <div class="info-section">
                    <h4>Action</h4>
                    <div class="info-row"><span class="info-label">Type</span><span class="info-value" id="actionType">-</span></div>
                    <div class="info-row"><span class="info-label">Target</span><span class="info-value" id="actionTarget">-</span></div>
                    <div class="info-row"><span class="info-label">Success Prob</span><span class="info-value" id="successProb">-</span></div>
                    <div class="info-row"><span class="info-label">Expected Value</span><span class="info-value" id="expValue">-</span></div>
                </div>
                <div class="info-section">
                    <h4>Result</h4>
                    <div class="info-row"><span class="info-label">Outcome</span><span class="info-value" id="result">-</span></div>
                    <div id="message" style="font-size: 12px; color: #888; margin-top: 5px;"></div>
                </div>
            </div>

            <div id="editor-tab" class="tab-content" style="display: none;">
                <div class="editor-tools">
                    <button class="tool-btn active" onclick="setTool('select')" id="tool-select">Select</button>
                    <button class="tool-btn" onclick="setTool('attacker')" id="tool-attacker">+ Attacker</button>
                    <button class="tool-btn" onclick="setTool('defender')" id="tool-defender">+ Defender</button>
                    <button class="tool-btn" onclick="setTool('ball')" id="tool-ball">+ Ball</button>
                </div>
                <div class="controls">
                    <button onclick="clearPitch()" class="danger">Clear</button>
                    <button onclick="loadDefault()" class="secondary">Default Setup</button>
                    <button onclick="runSimulation()">Run Simulation</button>
                </div>
                <div id="selectedInfo" style="display: none;" class="info-section">
                    <h4>Selected Player</h4>
                    <div class="info-row"><span class="info-label">ID</span><span class="info-value" id="selId">-</span></div>
                    <div class="info-row"><span class="info-label">Position</span><span class="info-value" id="selPos">-</span></div>
                    <button onclick="deleteSelected()" class="danger" style="margin-top: 10px; width: 100%;">Delete</button>
                </div>
                <p class="help-text">Click to add players. Drag to move. Right-click on player to set as ball carrier.</p>
            </div>

            <div id="analysis-tab" class="tab-content" style="display: none;">
                <div class="info-section">
                    <h4>Available Actions</h4>
                    <div class="action-list" id="actionList"><div style="color: #666; font-size: 12px;">Run simulation first</div></div>
                </div>
                <div class="info-section">
                    <h4>Simulation Stats</h4>
                    <div class="info-row"><span class="info-label">Total Steps</span><span class="info-value" id="statSteps">0</span></div>
                    <div class="info-row"><span class="info-label">Successful</span><span class="info-value" id="statSuccess">0</span></div>
                    <div class="info-row"><span class="info-label">Failed</span><span class="info-value" id="statFail">0</span></div>
                    <div class="info-row"><span class="info-label">Goals</span><span class="info-value" id="statGoals">0</span></div>
                </div>
            </div>
        </div>
    </div>

<script>
// ============================================
// DECISION ENGINE v3 - Pass Range, Facing, Shots
// ============================================

const PITCH_LENGTH = 105, PITCH_WIDTH = 68;
const HALF_LENGTH = 52.5, HALF_WIDTH = 34;
const GOAL_POS = { x: HALF_LENGTH, y: 0 };
const GOAL_WIDTH = 7.32; // Standard goal width

// Pass range limits
const MAX_PASS_DISTANCE = 35; // Max pass distance in meters
const FACING_CONE_ANGLE = Math.PI * 0.75; // 135 degrees - can pass within this cone

// Ball physics
const BALL_SPEED_GROUND = 18; // m/s for ground pass
const BALL_SPEED_LOFTED = 22; // m/s for lofted pass
const PLAYER_SPRINT_SPEED = 8; // m/s defender sprint speed

// Utility functions
function dist(a, b) { return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2); }
function norm(v) { return Math.sqrt(v.x * v.x + v.y * v.y); }
function dot(a, b) { return a.x * b.x + a.y * b.y; }

// ============================================
// ZONE-BASED GOAL PLANNING
// The engine identifies TARGET ZONES (high xG + space)
// Then finds the best PATH to get a player there
// ============================================

// Calculate xG for any position on the pitch
function getZoneXG(pos, defenders) {
    const distToGoal = dist(pos, GOAL_POS);
    if (distToGoal > 30) return 0; // Too far for meaningful xG

    // Base xG from distance
    let baseXG;
    if (distToGoal < 5) baseXG = 0.75;
    else if (distToGoal < 8) baseXG = 0.55;
    else if (distToGoal < 11) baseXG = 0.40;
    else if (distToGoal < 16) baseXG = 0.25;
    else if (distToGoal < 20) baseXG = 0.15;
    else if (distToGoal < 25) baseXG = 0.08;
    else baseXG = 0.04;

    // Angle factor
    const angle = Math.abs(Math.atan2(pos.y, GOAL_POS.x - pos.x));
    let angleFactor = 1.0;
    if (angle > 0.8) angleFactor = 0.2;
    else if (angle > 0.5) angleFactor = 0.5;
    else if (angle > 0.3) angleFactor = 0.75;

    // Space factor - how much room is there?
    let spaceFactor = 1.0;
    let nearestDef = Infinity;
    for (const def of defenders) {
        const d = dist(pos, def);
        if (d < nearestDef) nearestDef = d;
    }

    // Boost for space, penalty for pressure
    if (nearestDef < 2) spaceFactor = 0.2;
    else if (nearestDef < 4) spaceFactor = 0.4;
    else if (nearestDef < 6) spaceFactor = 0.6;
    else if (nearestDef < 8) spaceFactor = 0.8;
    else if (nearestDef > 10) spaceFactor = 1.5; // Open space boost
    else if (nearestDef > 15) spaceFactor = 2.0; // Very open

    return Math.min(0.95, baseXG * angleFactor * spaceFactor);
}

// Find the best scoring zones on the pitch
function findScoringZones(state) {
    const zones = [];

    // Sample the attacking third in a grid
    const xStart = HALF_LENGTH - 30; // Last 30m
    const xEnd = HALF_LENGTH - 3;    // Not past goal line
    const yStart = -20;              // Width of penalty area roughly
    const yEnd = 20;

    for (let x = xStart; x <= xEnd; x += 5) {
        for (let y = yStart; y <= yEnd; y += 5) {
            const pos = { x, y };
            const xG = getZoneXG(pos, state.defenders);

            if (xG > 0.05) { // Only consider zones with meaningful xG
                zones.push({
                    pos,
                    xG,
                    distToGoal: dist(pos, GOAL_POS)
                });
            }
        }
    }

    // Sort by xG (best zones first)
    zones.sort((a, b) => b.xG - a.xG);

    // Return top zones (don't need all of them)
    return zones.slice(0, 10);
}

// Check if a player can reach a zone (run into space)
function canPlayerReachZone(player, zone, state, isCarrier) {
    const runDist = dist(player, zone.pos);

    // Can't run too far in one action
    if (runDist > 15) return { canReach: false };

    // If carrier, they'd have to dribble
    if (isCarrier) {
        // Check path for defenders
        let blocked = false;
        for (const def of state.defenders) {
            const perpDist = pointToSegmentDist(def, player, zone.pos);
            if (perpDist < 3 && def.x > player.x) {
                blocked = true;
                break;
            }
        }
        return {
            canReach: !blocked,
            method: 'dribble',
            distance: runDist,
            probability: blocked ? 0.1 : Math.max(0.2, 0.8 - runDist / 20)
        };
    }

    // Off-ball run - check if defender can catch them
    let canRun = true;
    for (const def of state.defenders) {
        const defDist = dist(def, zone.pos);
        // If defender is closer to zone, they'll get there first
        if (defDist < runDist - 3) {
            canRun = false;
            break;
        }
    }

    return {
        canReach: canRun,
        method: 'run',
        distance: runDist,
        probability: canRun ? 0.9 : 0.3
    };
}

// Check if we can pass to a zone (pass into space or to player)
function canPassToZone(state, zone) {
    const from = state.ball;
    const to = zone.pos;
    const passDist = dist(from, to);

    if (passDist > MAX_PASS_DISTANCE) return { canPass: false };

    // Check for interceptions
    let interceptProb = 0;
    for (const def of state.defenders) {
        const perpDist = pointToSegmentDist(def, from, to);
        if (perpDist < 2) interceptProb += 0.4;
        else if (perpDist < 4) interceptProb += 0.2;
        else if (perpDist < 6) interceptProb += 0.1;
    }

    const successProb = Math.max(0.1, 1 - interceptProb);

    return {
        canPass: successProb > 0.3,
        successProb,
        distance: passDist
    };
}

// Find best path to get a player into a zone
function findPathToZone(state, zone) {
    const paths = [];
    const carrier = state.attackers.find(a => a.id === state.carrierId);

    // Option 1: Carrier dribbles to zone
    if (carrier) {
        const dribblePath = canPlayerReachZone(carrier, zone, state, true);
        if (dribblePath.canReach) {
            paths.push({
                type: 'dribble',
                player: carrier.id,
                zone: zone.pos,
                xG: zone.xG,
                probability: dribblePath.probability,
                expectedXG: zone.xG * dribblePath.probability,
                steps: 1
            });
        }
    }

    // Option 2: Pass to player already near zone
    for (const attacker of state.attackers) {
        if (attacker.id === state.carrierId) continue;

        const playerDistToZone = dist(attacker, zone.pos);
        if (playerDistToZone < 8) {
            // Player is near the zone - can we pass to them?
            const passCheck = canPassToZone(state, { pos: attacker });
            if (passCheck.canPass) {
                paths.push({
                    type: 'pass',
                    player: attacker.id,
                    zone: zone.pos,
                    xG: zone.xG,
                    probability: passCheck.successProb,
                    expectedXG: zone.xG * passCheck.successProb,
                    steps: 1
                });
            }
        }
    }

    // Option 3: Pass to player who can then move to zone
    for (const attacker of state.attackers) {
        if (attacker.id === state.carrierId) continue;

        const passCheck = canPassToZone(state, { pos: attacker });
        if (!passCheck.canPass) continue;

        // After receiving, can they reach the zone?
        const runCheck = canPlayerReachZone(attacker, zone, state, false);
        if (runCheck.canReach) {
            const combinedProb = passCheck.successProb * runCheck.probability;
            paths.push({
                type: 'pass-then-move',
                player: attacker.id,
                zone: zone.pos,
                xG: zone.xG,
                probability: combinedProb,
                expectedXG: zone.xG * combinedProb,
                steps: 2,
                passProb: passCheck.successProb,
                moveProb: runCheck.probability
            });
        }
    }

    // Sort by expected xG (best paths first)
    paths.sort((a, b) => b.expectedXG - a.expectedXG);

    return paths.length > 0 ? paths[0] : null;
}

// MAIN: Find the best play (zone + path combination)
function findBestPlay(state) {
    // 1. Find best scoring zones
    const zones = findScoringZones(state);

    // 2. For each zone, find the best path to get there
    const plays = [];
    for (const zone of zones) {
        const path = findPathToZone(state, zone);
        if (path) {
            plays.push({
                zone,
                path,
                score: path.expectedXG
            });
        }
    }

    // 3. Sort by expected xG
    plays.sort((a, b) => b.score - a.score);

    // Return all viable plays (for display), best first
    return plays;
}

// Get angle between two points
function angleBetween(from, to) {
    return Math.atan2(to.y - from.y, to.x - from.x);
}

// Check if target is within facing cone
function isInFacingCone(carrier, target, facingAngle) {
    const angleToTarget = angleBetween(carrier, target);
    let angleDiff = Math.abs(angleToTarget - facingAngle);
    if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
    return angleDiff <= FACING_CONE_ANGLE / 2;
}

// Point to line segment distance
function pointToSegmentDist(p, a, b) {
    const ab = { x: b.x - a.x, y: b.y - a.y };
    const ap = { x: p.x - a.x, y: p.y - a.y };
    const abLen = norm(ab);
    if (abLen < 0.1) return dist(p, a);
    const t = Math.max(0, Math.min(1, dot(ap, ab) / (abLen * abLen)));
    const closest = { x: a.x + t * ab.x, y: a.y + t * ab.y };
    return dist(p, closest);
}

// Calculate how much space a player has (distance to nearest defender)
function getPlayerSpace(player, defenders) {
    let minDist = Infinity;
    for (const def of defenders) {
        const d = dist(player, def);
        if (d < minDist) minDist = d;
    }
    return minDist;
}

// Check if player is the "free man" (most space)
function findFreeMan(attackers, defenders, carrierId) {
    let maxSpace = 0;
    let freeMan = null;
    for (const att of attackers) {
        if (att.id === carrierId) continue;
        const space = getPlayerSpace(att, defenders);
        if (space > maxSpace) {
            maxSpace = space;
            freeMan = att;
        }
    }
    return { player: freeMan, space: maxSpace };
}

// Calculate progressive distance (how much closer to goal)
function progressiveValue(from, to) {
    const fromGoalDist = dist(from, GOAL_POS);
    const toGoalDist = dist(to, GOAL_POS);
    return (fromGoalDist - toGoalDist) / fromGoalDist;
}

// Get carrier's facing direction (toward goal by default, or toward ball movement)
function getCarrierFacing(state) {
    const carrier = state.attackers.find(a => a.id === state.carrierId);
    if (!carrier) return 0;
    // Default: facing toward goal
    return angleBetween(carrier, GOAL_POS);
}

// Calculate ball travel time and if defender can intercept
function canDefenderIntercept(def, from, to, passDist) {
    // Ball travel time
    const ballTravelTime = passDist / BALL_SPEED_GROUND;

    // Find closest point on pass line to defender
    const ab = { x: to.x - from.x, y: to.y - from.y };
    const ap = { x: def.x - from.x, y: def.y - from.y };
    const abLen = norm(ab);
    const t = Math.max(0, Math.min(1, dot(ap, ab) / (abLen * abLen)));
    const interceptPoint = { x: from.x + t * ab.x, y: from.y + t * ab.y };

    // Time for ball to reach intercept point
    const ballDistToIntercept = dist(from, interceptPoint);
    const ballTimeToIntercept = ballDistToIntercept / BALL_SPEED_GROUND;

    // Distance defender needs to run to intercept point
    const defDistToIntercept = dist(def, interceptPoint);

    // Time for defender to reach intercept point (with reaction time)
    const reactionTime = 0.3; // 300ms reaction delay
    const defTimeToIntercept = reactionTime + defDistToIntercept / PLAYER_SPRINT_SPEED;

    // Can intercept if defender arrives before or at same time as ball
    const canIntercept = defTimeToIntercept <= ballTimeToIntercept + 0.2; // 0.2s margin

    return {
        canIntercept,
        interceptPoint,
        ballTime: ballTimeToIntercept,
        defTime: defTimeToIntercept,
        margin: ballTimeToIntercept - defTimeToIntercept
    };
}

// Quick xG estimate for a receiver position (simplified)
function evaluateReceiverShotPotential(receiverPos, defenders) {
    const distToGoal = dist(receiverPos, GOAL_POS);

    // No shot potential if too far
    if (distToGoal > 25) return 0;

    // Base xG from distance
    let xG;
    if (distToGoal < 5) xG = 0.60;
    else if (distToGoal < 8) xG = 0.40;
    else if (distToGoal < 11) xG = 0.30;
    else if (distToGoal < 16) xG = 0.18;
    else if (distToGoal < 20) xG = 0.08;
    else xG = 0.03;

    // Angle factor
    const angle = Math.abs(Math.atan2(receiverPos.y, GOAL_POS.x - receiverPos.x));
    if (angle > 0.8) xG *= 0.3;
    else if (angle > 0.5) xG *= 0.5;
    else if (angle > 0.3) xG *= 0.75;

    // Defender pressure
    for (const def of defenders) {
        const defDist = dist(receiverPos, def);
        if (defDist < 2) xG *= 0.4;
        else if (defDist < 4) xG *= 0.6;
        else if (defDist < 6) xG *= 0.8;
    }

    return xG;
}

// Evaluate pass to a target player - WITH RANGE, FACING & BALL TRAVEL TIME
function evaluatePass(state, targetPlayer) {
    const carrier = state.attackers.find(a => a.id === state.carrierId);
    if (!carrier) return null;

    const from = state.ball;
    const to = targetPlayer;
    const passDist = dist(from, to);

    // CHECK 1: Pass distance limit
    if (passDist > MAX_PASS_DISTANCE) {
        return null; // Too far to pass
    }

    // CHECK 2: Facing direction - can only pass in front
    // EXCEPTIONS: Short passes and cutbacks to better positions are always allowed
    const facingAngle = getCarrierFacing(state);
    const inFacingCone = isInFacingCone(carrier, to, facingAngle);

    // Allow pass if:
    // 1. In facing cone (normal pass)
    // 2. Short pass < 10m (can just tap it)
    // 3. Receiver is closer to goal (cutback/square ball)
    // 4. In the attacking third (final third creativity)
    const isShortPass = passDist < 10;
    const receiverCloserToGoal = dist(to, GOAL_POS) < dist(from, GOAL_POS);
    const inAttackingThird = from.x > HALF_LENGTH - 35; // Last 35m

    if (!inFacingCone && !isShortPass && !receiverCloserToGoal && !inAttackingThird) {
        return null; // Can't pass behind unless exceptions apply
    }

    // Penalty for passing outside facing cone (harder to execute)
    const facingPenalty = inFacingCone ? 1.0 : 0.85;

    // Calculate ball travel time
    const ballTravelTime = passDist / BALL_SPEED_GROUND;

    // 1. Distance/time factor: longer passes = more time for defenders
    const timeFactor = Math.max(0.3, 1 - ballTravelTime / 2.5); // 2.5s max reasonable pass time

    // 2. Receiver space - crucial factor
    const receiverSpace = getPlayerSpace(to, state.defenders);
    let spaceFactor = 1.0;
    if (receiverSpace < 3) spaceFactor = 0.4;
    else if (receiverSpace < 5) spaceFactor = 0.6;
    else if (receiverSpace < 8) spaceFactor = 0.8;
    else if (receiverSpace > 12) spaceFactor = 1.2;

    // 3. Progressive pass bonus
    const progression = progressiveValue(from, to);
    const progressBonus = progression > 0.1 ? 1 + progression * 0.5 : 0.8;

    // 4. Free man bonus
    const freeManInfo = findFreeMan(state.attackers, state.defenders, state.carrierId);
    const isFreeMan = freeManInfo.player && freeManInfo.player.id === targetPlayer.id;
    const freeManBonus = isFreeMan ? 1.15 : 1.0;

    // 5. Interception risk - based on ball travel time and defender positions
    let interceptionRisk = 0;
    let potentialInterceptors = [];

    for (const def of state.defenders) {
        const intercept = canDefenderIntercept(def, from, to, passDist);

        if (intercept.canIntercept) {
            // Defender can reach the ball in time
            const urgency = Math.max(0, 0.5 - intercept.margin); // Higher if close race
            interceptionRisk += 0.3 + urgency;
            potentialInterceptors.push({ def, ...intercept });
        } else {
            // Even if can't intercept, nearby defenders are a threat
            const perpDist = pointToSegmentDist(def, from, to);
            if (perpDist < 3) interceptionRisk += 0.1;
            else if (perpDist < 5) interceptionRisk += 0.05;
        }
    }

    // 6. Passing into pressure penalty
    const pressurePenalty = receiverSpace < 4 ? 0.15 : 0;
    interceptionRisk += pressurePenalty;

    const successProb = Math.max(0.1, timeFactor * spaceFactor * facingPenalty * (1 - Math.min(interceptionRisk, 0.85)));

    const distToGoal = dist(to, GOAL_POS);
    const positionValue = Math.max(0.1, 1 - distToGoal / 60);

    // BIG BONUS: If receiver would have a good shot, this pass is very valuable
    // Simulate what xG the receiver would have
    const receiverShotXG = evaluateReceiverShotPotential(to, state.defenders);
    const shotCreationBonus = receiverShotXG > 0.15 ? 1.5 : (receiverShotXG > 0.08 ? 1.2 : 1.0);

    const valueIfSuccess = positionValue * progressBonus * freeManBonus * shotCreationBonus;
    const riskIfFail = receiverSpace < 5 ? 0.5 : 0.35;

    const expectedValue = successProb * valueIfSuccess - (1 - successProb) * riskIfFail;

    return {
        type: 'pass',
        target: { x: to.x, y: to.y },
        targetPlayer: targetPlayer.id,
        successProb,
        expectedValue,
        valueIfSuccess,
        riskIfFail,
        receiverSpace: receiverSpace.toFixed(1),
        isFreeMan,
        isProgressive: progression > 0.1,
        distance: passDist.toFixed(1),
        travelTime: ballTravelTime.toFixed(2),
        interceptors: potentialInterceptors.length,
        receiverXG: (receiverShotXG * 100).toFixed(1), // What xG receiver would have
        isCutback: !inFacingCone && receiverCloserToGoal
    };
}

// Evaluate shot on goal - xG MODEL
// Shot is ALWAYS an option within range - xG tells you if it's worth it
function evaluateShot(state) {
    const from = state.ball;
    const distToGoal = dist(from, GOAL_POS);

    // Max shooting range - beyond this, no shot option
    const MAX_SHOT_RANGE = 35;
    if (distToGoal > MAX_SHOT_RANGE) return null;

    // Zone detection
    const inPenaltyBox = from.x > HALF_LENGTH - 16.5 && Math.abs(from.y) < 20;
    const inSixYardBox = from.x > HALF_LENGTH - 5.5 && Math.abs(from.y) < 9.16;

    // ========================================
    // xG CALCULATION - Based on real xG models
    // ========================================

    // 1. BASE xG from distance (these are BASE values - get multiplied by pressure factor)
    // An unmarked shot will be boosted 2-2.5x, so a 20m unmarked shot = 0.15 * 2.5 = 37.5%
    let baseXG;
    if (distToGoal < 5) baseXG = 0.75;      // Tap-in range
    else if (distToGoal < 8) baseXG = 0.55;  // Close range
    else if (distToGoal < 11) baseXG = 0.40; // Penalty spot range
    else if (distToGoal < 16) baseXG = 0.25; // Edge of box
    else if (distToGoal < 20) baseXG = 0.15; // Just outside box
    else if (distToGoal < 25) baseXG = 0.08; // Long range
    else baseXG = 0.04; // Very long range

    // 2. ANGLE factor - central shots worth more
    // Calculate angle to goal center
    const angleToGoalCenter = Math.abs(Math.atan2(from.y, GOAL_POS.x - from.x));
    // Also calculate visible goal angle (how much of goal you can see)
    const visibleGoalAngle = 2 * Math.atan2(GOAL_WIDTH / 2, distToGoal);

    let angleFactor;
    if (angleToGoalCenter < 0.15) angleFactor = 1.0; // Dead center
    else if (angleToGoalCenter < 0.3) angleFactor = 0.85;
    else if (angleToGoalCenter < 0.5) angleFactor = 0.65;
    else if (angleToGoalCenter < 0.8) angleFactor = 0.40;
    else angleFactor = 0.20; // Very tight angle

    // 3. DEFENDER PRESSURE - affects xG significantly
    // defenderPressure > 1.0 = unmarked (BOOST), < 1.0 = pressured (reduce)
    let defenderPressure = 1.0;
    let nearestDefenderDist = Infinity;
    let defendersClose = 0; // Count defenders within 10m

    for (const def of state.defenders) {
        const defDist = dist(from, def);
        if (defDist < nearestDefenderDist) nearestDefenderDist = defDist;
        if (defDist < 10) defendersClose++;

        // Close defender reduces xG
        if (defDist < 1.5) defenderPressure *= 0.3; // Defender right on you
        else if (defDist < 3) defenderPressure *= 0.5;
        else if (defDist < 5) defenderPressure *= 0.7;
        else if (defDist < 8) defenderPressure *= 0.85;

        // Defender in shot path blocks the shot
        const perpDist = pointToSegmentDist(def, from, GOAL_POS);
        if (def.x > from.x) { // Only defenders in front matter
            if (perpDist < 1) defenderPressure *= 0.2; // Direct block
            else if (perpDist < 2) defenderPressure *= 0.4;
            else if (perpDist < 3) defenderPressure *= 0.6;
            else if (perpDist < 5) defenderPressure *= 0.8;
        }
    }

    // BOOST for being unmarked - time to pick your spot
    // No defenders within 10m = huge boost
    if (defendersClose === 0) {
        defenderPressure *= 2.5; // Completely unmarked - much easier shot
    } else if (nearestDefenderDist > 8) {
        defenderPressure *= 1.8; // Lots of space
    } else if (nearestDefenderDist > 5) {
        defenderPressure *= 1.3; // Good space
    }

    // 4. COUNT defenders between ball and goal
    let defendersInPath = 0;
    for (const def of state.defenders) {
        if (def.x > from.x && def.x < GOAL_POS.x) {
            const perpDist = pointToSegmentDist(def, from, GOAL_POS);
            if (perpDist < 4) defendersInPath++;
        }
    }

    // 5. FINAL xG calculation
    const xG = Math.min(0.95, Math.max(0.01, baseXG * angleFactor * defenderPressure));

    // Expected value: xG (probability of goal) minus cost of missing
    // Possession loss risk is low for shots - worst case is a goal kick
    let possessionLossRisk = 0.15;
    if (defendersClose === 0) possessionLossRisk = 0.05; // Miss = corner or goal kick, not bad
    else if (nearestDefenderDist > 5) possessionLossRisk = 0.1;

    // EV = P(goal) × 1 - P(miss) × risk = xG - (1-xG) × risk
    const expectedValue = xG - (1 - xG) * possessionLossRisk;

    return {
        type: 'shot',
        target: GOAL_POS,
        targetPlayer: null,
        successProb: xG,
        expectedValue,
        valueIfSuccess: 1.0,
        riskIfFail: possessionLossRisk,
        distToGoal: distToGoal.toFixed(1),
        inBox: inPenaltyBox,
        inSixYard: inSixYardBox,
        xG: (xG * 100).toFixed(1), // Display as percentage
        defendersBlocking: defendersInPath,
        angle: (angleToGoalCenter * 180 / Math.PI).toFixed(0) // Angle in degrees
    };
}

// Evaluate dribble forward
function evaluateDribble(state) {
    const from = state.ball;
    const carrier = state.attackers.find(a => a.id === state.carrierId);
    if (!carrier) return null;

    // Dribble target: 8m forward
    const target = { x: Math.min(from.x + 8, HALF_LENGTH - 5), y: from.y };

    // Check defenders at START, along PATH, and at TARGET
    let pressureFactor = 1;
    for (const def of state.defenders) {
        // Defender at current position
        const defDistStart = dist(from, def);
        if (defDistStart < 2) pressureFactor *= 0.15;
        else if (defDistStart < 4) pressureFactor *= 0.4;
        else if (defDistStart < 6) pressureFactor *= 0.7;

        // Defender at target position (dribbling INTO them)
        const defDistTarget = dist(target, def);
        if (defDistTarget < 2) pressureFactor *= 0.1; // Dribbling right into defender
        else if (defDistTarget < 4) pressureFactor *= 0.3;
        else if (defDistTarget < 6) pressureFactor *= 0.6;

        // Defender along the path
        const perpDist = pointToSegmentDist(def, from, target);
        if (perpDist < 2 && def.x > from.x && def.x < target.x) {
            pressureFactor *= 0.2; // Defender can intercept
        }
    }

    const successProb = Math.max(0.05, pressureFactor * 0.65); // Base 65%, can go very low
    const distToGoal = dist(target, GOAL_POS);
    const valueIfSuccess = Math.max(0.2, 0.8 - distToGoal / 50);
    const riskIfFail = 0.4; // Losing ball in attacking position is costly

    const expectedValue = successProb * valueIfSuccess - (1 - successProb) * riskIfFail;

    return {
        type: 'dribble',
        target,
        targetPlayer: null,
        successProb,
        expectedValue,
        valueIfSuccess,
        riskIfFail
    };
}

// ============================================
// MULTI-STEP LOOKAHEAD - Find passing sequences
// ============================================

const LOOKAHEAD_DEPTH = 2; // How many steps ahead to look
const FUTURE_DISCOUNT = 0.85; // Discount factor for future value

// Simulate state after successful pass - PASSER MAKES A RUN
function simulatePassSuccess(state, passAction) {
    const newState = JSON.parse(JSON.stringify(state));
    newState.ball = { x: passAction.target.x, y: passAction.target.y };

    // Find the passer and make them run forward (one-two potential)
    const passerIdx = newState.attackers.findIndex(a => a.id === state.carrierId);
    if (passerIdx >= 0) {
        const passer = newState.attackers[passerIdx];
        const receiver = passAction.target;

        // Passer runs forward into space after passing
        // Direction: toward goal, but also toward where ball went
        const runDistance = 8; // meters
        let runX = passer.x + runDistance * 0.8; // Mostly forward
        let runY = passer.y;

        // If pass was wide, run more central (overlap/underlap)
        if (Math.abs(receiver.y) > Math.abs(passer.y)) {
            // Pass went wider - passer cuts inside
            runY = passer.y * 0.5;
        } else {
            // Pass went central - passer overlaps wide
            runY = passer.y + (passer.y > 0 ? 5 : -5);
        }

        // Don't run past the goal line
        runX = Math.min(runX, HALF_LENGTH - 8);
        runY = Math.max(-HALF_WIDTH + 5, Math.min(HALF_WIDTH - 5, runY));

        // Check if run destination has space (don't run into defenders)
        let runBlocked = false;
        for (const def of newState.defenders) {
            if (dist({ x: runX, y: runY }, def) < 3) {
                runBlocked = true;
                break;
            }
        }

        // Only make the run if there's space
        if (!runBlocked) {
            newState.attackers[passerIdx].x = runX;
            newState.attackers[passerIdx].y = runY;
        }
    }

    newState.carrierId = passAction.targetPlayer;
    return newState;
}

// Check if a one-two is possible (pass and get it back)
function evaluateOneTwoPotential(state, passAction) {
    // Simulate the pass
    const afterPass = simulatePassSuccess(state, passAction);

    // Check if receiver can pass back to the (now moved) original passer
    const originalPasser = afterPass.attackers.find(a => a.id === state.carrierId);
    if (!originalPasser) return null;

    // Evaluate a return pass
    const returnPass = evaluatePass(afterPass, originalPasser);
    if (!returnPass || returnPass.successProb < 0.5) return null;

    // Check what the original passer could do after getting the ball back
    const afterReturn = simulatePassSuccess(afterPass, returnPass);
    const finalShot = evaluateShot(afterReturn);

    if (finalShot && parseFloat(finalShot.xG) > 15) {
        return {
            isOneTwo: true,
            returnPassProb: returnPass.successProb,
            finalXG: finalShot.xG,
            passerNewPos: { x: originalPasser.x, y: originalPasser.y }
        };
    }

    return null;
}

// Simulate state after successful dribble
function simulateDribbleSuccess(state, dribbleAction) {
    const newState = JSON.parse(JSON.stringify(state));
    newState.ball = { x: dribbleAction.target.x, y: dribbleAction.target.y };
    // Move carrier to new position
    const carrierIdx = newState.attackers.findIndex(a => a.id === state.carrierId);
    if (carrierIdx >= 0) {
        newState.attackers[carrierIdx].x = dribbleAction.target.x;
        newState.attackers[carrierIdx].y = dribbleAction.target.y;
    }
    return newState;
}

// Evaluate position value (how good is this state for attacking team)
function evaluatePositionValue(state) {
    const ballDistToGoal = dist(state.ball, GOAL_POS);

    // Base value from ball position
    let value = Math.max(0, 1 - ballDistToGoal / 60);

    // Bonus for ball carrier having space
    const carrier = state.attackers.find(a => a.id === state.carrierId);
    if (carrier) {
        const carrierSpace = getPlayerSpace(carrier, state.defenders);
        if (carrierSpace > 10) value += 0.15;
        else if (carrierSpace > 6) value += 0.08;
    }

    // Check if a shot opportunity exists
    const shotEval = evaluateShot(state);
    if (shotEval && shotEval.xG > 10) { // >10% xG
        value = Math.max(value, parseFloat(shotEval.xG) / 100);
    }

    return value;
}

// Recursive lookahead evaluation
function evaluateWithLookahead(state, action, depth) {
    if (depth === 0) {
        // Base case: just return immediate expected value
        return action.expectedValue;
    }

    // For shots, no lookahead needed - it's a terminal action
    if (action.type === 'shot') {
        return action.expectedValue;
    }

    // Calculate future value if action succeeds
    let futureValue = 0;
    let futureAction = null;

    if (action.type === 'pass') {
        const futureState = simulatePassSuccess(state, action);

        // Find best action from future state (with reduced depth)
        const futureActions = findActionsBasic(futureState);
        if (futureActions.length > 0) {
            // Evaluate each future action with lookahead
            let bestFutureValue = -Infinity;
            for (const fa of futureActions) {
                const faValue = evaluateWithLookahead(futureState, fa, depth - 1);
                if (faValue > bestFutureValue) {
                    bestFutureValue = faValue;
                    futureAction = fa;
                }
            }
            futureValue = bestFutureValue;
        } else {
            // No actions available, use position value
            futureValue = evaluatePositionValue(futureState);
        }
    } else if (action.type === 'dribble') {
        const futureState = simulateDribbleSuccess(state, action);
        const futureActions = findActionsBasic(futureState);
        if (futureActions.length > 0) {
            let bestFutureValue = -Infinity;
            for (const fa of futureActions) {
                const faValue = evaluateWithLookahead(futureState, fa, depth - 1);
                if (faValue > bestFutureValue) {
                    bestFutureValue = faValue;
                    futureAction = fa;
                }
            }
            futureValue = bestFutureValue;
        } else {
            futureValue = evaluatePositionValue(futureState);
        }
    }

    // Combined value: probability-weighted outcome
    // Success: you get to take the best future action (no double counting)
    // Failure: you lose possession
    const successValue = FUTURE_DISCOUNT * futureValue;
    const failValue = -action.riskIfFail;

    // EV = P(success) × futureValue - P(fail) × lossRisk
    const lookaheadEV = action.successProb * successValue + (1 - action.successProb) * failValue;

    return lookaheadEV;
}

// Basic action finding without lookahead (to avoid infinite recursion)
function findActionsBasic(state) {
    const actions = [];

    for (const attacker of state.attackers) {
        if (attacker.id === state.carrierId) continue;
        const passAction = evaluatePass(state, attacker);
        if (passAction && passAction.expectedValue > -0.5) {
            actions.push(passAction);
        }
    }

    const shot = evaluateShot(state);
    if (shot) actions.push(shot);

    const dribble = evaluateDribble(state);
    if (dribble && dribble.expectedValue > -0.3) actions.push(dribble);

    actions.sort((a, b) => b.expectedValue - a.expectedValue);
    return actions;
}

// Find all available actions WITH LOOKAHEAD
function findActions(state) {
    const actions = [];

    // Pass to each teammate
    for (const attacker of state.attackers) {
        if (attacker.id === state.carrierId) continue;
        const passAction = evaluatePass(state, attacker);
        if (passAction && passAction.expectedValue > -0.3) {
            // Calculate lookahead value
            const lookaheadValue = evaluateWithLookahead(state, passAction, LOOKAHEAD_DEPTH);
            passAction.lookaheadValue = lookaheadValue;
            passAction.originalEV = passAction.expectedValue;
            passAction.expectedValue = lookaheadValue; // Use lookahead for sorting

            // Find what the receiver could do next
            const futureState = simulatePassSuccess(state, passAction);
            const futureActions = findActionsBasic(futureState);
            if (futureActions.length > 0) {
                passAction.nextBestAction = futureActions[0].type;
                if (futureActions[0].type === 'shot') {
                    passAction.createsShot = true;
                    passAction.shotXG = futureActions[0].xG;
                }

                // Check for ONE-TWO potential (give and go)
                // Look for return pass to the original passer who has now made a run
                const originalPasserId = state.carrierId;
                const movedPasser = futureState.attackers.find(a => a.id === originalPasserId);
                if (movedPasser) {
                    const returnPass = futureActions.find(a =>
                        a.type === 'pass' && a.targetPlayer === originalPasserId
                    );
                    if (returnPass && returnPass.successProb > 0.5) {
                        passAction.isOneTwo = true;
                        passAction.oneTwoReturnProb = (returnPass.successProb * 100).toFixed(0);

                        // Check what happens after the one-two
                        const afterOneTwo = simulatePassSuccess(futureState, returnPass);
                        const oneTwoShot = evaluateShot(afterOneTwo);
                        if (oneTwoShot && parseFloat(oneTwoShot.xG) > 10) {
                            passAction.oneTwoXG = oneTwoShot.xG;
                        }
                    }
                }
            }

            actions.push(passAction);
        }
    }

    // Shot on goal - no lookahead needed
    const shot = evaluateShot(state);
    if (shot) {
        shot.lookaheadValue = shot.expectedValue;
        shot.originalEV = shot.expectedValue;
        actions.push(shot);
    }

    // Dribble with lookahead
    const dribble = evaluateDribble(state);
    if (dribble && dribble.expectedValue > -0.2) {
        const lookaheadValue = evaluateWithLookahead(state, dribble, LOOKAHEAD_DEPTH);
        dribble.lookaheadValue = lookaheadValue;
        dribble.originalEV = dribble.expectedValue;
        dribble.expectedValue = lookaheadValue;
        actions.push(dribble);
    }

    // Sort by lookahead expected value
    actions.sort((a, b) => b.expectedValue - a.expectedValue);

    return actions;
}

// Execute an action
function executeAction(state, action) {
    const roll = Math.random();
    const success = roll < action.successProb;

    let newState = JSON.parse(JSON.stringify(state));
    let result, message;

    if (action.type === 'pass') {
        if (success) {
            newState.ball = { x: action.target.x, y: action.target.y };
            newState.carrierId = action.targetPlayer;
            result = 'success';
            message = `Pass to ${action.targetPlayer} completed`;
        } else {
            // REALISTIC FAILURE - ball lands along pass path or nearby

            // Find where along the pass the ball was intercepted
            const from = state.ball;
            const to = action.target;
            const passDist = dist(from, to);

            // Find the defender who intercepted
            let interceptor = null;
            let interceptPoint = null;
            let bestInterceptDist = Infinity;

            for (const def of state.defenders) {
                const intercept = canDefenderIntercept(def, from, to, passDist);
                if (intercept.canIntercept) {
                    const d = dist(def, intercept.interceptPoint);
                    if (d < bestInterceptDist) {
                        bestInterceptDist = d;
                        interceptor = def;
                        interceptPoint = intercept.interceptPoint;
                    }
                }
            }

            // If no clear interceptor, use closest defender to pass line
            if (!interceptor) {
                let minPerpDist = Infinity;
                for (const def of state.defenders) {
                    const perpDist = pointToSegmentDist(def, from, to);
                    if (perpDist < minPerpDist) {
                        minPerpDist = perpDist;
                        interceptor = def;
                        // Calculate intercept point on pass line
                        const ab = { x: to.x - from.x, y: to.y - from.y };
                        const ap = { x: def.x - from.x, y: def.y - from.y };
                        const abLen = norm(ab);
                        const t = Math.max(0.1, Math.min(0.9, dot(ap, ab) / (abLen * abLen)));
                        interceptPoint = { x: from.x + t * ab.x, y: from.y + t * ab.y };
                    }
                }
            }

            // Ball lands in a zone around the intercept point
            // Add some randomness to represent deflections, bobbles, etc.
            const scatter = 2 + Math.random() * 3; // 2-5m scatter
            const scatterAngle = Math.random() * Math.PI * 2;
            const landingX = interceptPoint.x + Math.cos(scatterAngle) * scatter;
            const landingY = interceptPoint.y + Math.sin(scatterAngle) * scatter;

            // Clamp to pitch bounds
            newState.ball = {
                x: Math.max(-HALF_LENGTH + 2, Math.min(HALF_LENGTH - 2, landingX)),
                y: Math.max(-HALF_WIDTH + 2, Math.min(HALF_WIDTH - 2, landingY))
            };

            // Defender gains possession if close enough to landing spot
            const defDistToLanding = dist(interceptor, newState.ball);
            if (defDistToLanding < 4) {
                // Defender controls the ball
                newState.ball = { x: interceptor.x, y: interceptor.y };
                newState.carrierId = null; // Possession lost
                result = 'intercepted';
                message = `Pass intercepted by ${interceptor.id}`;
            } else {
                // Loose ball - 50/50 situation
                newState.carrierId = null;
                result = 'intercepted';
                message = `Pass cut out - loose ball near ${interceptor.id}`;
            }
        }
    } else if (action.type === 'shot') {
        if (success) {
            newState.ball = { x: GOAL_POS.x, y: 0 };
            result = 'goal';
            message = 'GOAL!';
        } else {
            // Shot failure - ball goes to various places
            const failType = Math.random();
            if (failType < 0.4) {
                // Saved by keeper - ball near goal
                newState.ball = {
                    x: HALF_LENGTH - 3 - Math.random() * 5,
                    y: (Math.random() - 0.5) * 12
                };
                message = 'Shot saved!';
            } else if (failType < 0.7) {
                // Wide/over - out for goal kick area
                newState.ball = {
                    x: HALF_LENGTH - 8,
                    y: (Math.random() - 0.5) * 20
                };
                message = 'Shot wide!';
            } else {
                // Blocked by defender
                const blocker = state.defenders.find(d => d.x > state.ball.x) || state.defenders[0];
                newState.ball = {
                    x: blocker.x + (Math.random() - 0.5) * 6,
                    y: blocker.y + (Math.random() - 0.5) * 6
                };
                message = `Shot blocked by ${blocker.id}!`;
            }
            newState.carrierId = null;
            result = 'missed';
        }
    } else if (action.type === 'dribble') {
        if (success) {
            newState.ball = { x: action.target.x, y: action.target.y };
            // Move carrier
            const carrierIdx = newState.attackers.findIndex(a => a.id === state.carrierId);
            if (carrierIdx >= 0) {
                newState.attackers[carrierIdx].x = action.target.x;
                newState.attackers[carrierIdx].y = action.target.y;
            }
            result = 'success';
            message = `${state.carrierId} dribbles forward`;
        } else {
            // Tackled
            let nearestDef = state.defenders[0];
            let minDist = Infinity;
            for (const def of state.defenders) {
                const d = dist(def, state.ball);
                if (d < minDist) { minDist = d; nearestDef = def; }
            }
            newState.ball = { x: nearestDef.x, y: nearestDef.y };
            newState.carrierId = null;
            result = 'tackled';
            message = `Tackled by ${nearestDef.id}`;
        }
    }

    // ==========================================
    // OFF-BALL MOVEMENT - Attackers reposition
    // ==========================================
    moveAttackersOffBall(newState);

    // ==========================================
    // DEFENDER AI - Better positioning
    // ==========================================
    moveDefenders(newState);

    return { newState, result, message, action };
}

// Off-ball movement for attackers
function moveAttackersOffBall(state) {
    const carrier = state.attackers.find(a => a.id === state.carrierId);
    if (!carrier) return;

    for (let i = 0; i < state.attackers.length; i++) {
        const att = state.attackers[i];
        if (att.id === state.carrierId) continue; // Carrier doesn't move

        // Find nearest defender to this attacker
        let nearestDef = null;
        let nearestDefDist = Infinity;
        for (const def of state.defenders) {
            const d = dist(att, def);
            if (d < nearestDefDist) {
                nearestDefDist = d;
                nearestDef = def;
            }
        }

        // Movement logic based on situation
        let moveX = 0, moveY = 0;
        const currentSpace = nearestDefDist;

        // 1. If too close to defender, move to create space
        if (currentSpace < 5 && nearestDef) {
            // Move away from nearest defender
            const awayX = att.x - nearestDef.x;
            const awayY = att.y - nearestDef.y;
            const awayDist = Math.sqrt(awayX * awayX + awayY * awayY);
            if (awayDist > 0.1) {
                moveX += (awayX / awayDist) * 2;
                moveY += (awayY / awayDist) * 1.5;
            }
        }

        // 2. Support run - move toward ball carrier if far away
        const distToCarrier = dist(att, carrier);
        if (distToCarrier > 25 && att.x < carrier.x + 15) {
            const toCarrier = { x: carrier.x - att.x, y: carrier.y - att.y };
            const d = norm(toCarrier);
            moveX += (toCarrier.x / d) * 1.5;
            moveY += (toCarrier.y / d) * 1;
        }

        // 3. Forward run - if in front of ball and have space, move toward goal
        if (att.x > carrier.x && currentSpace > 6 && att.x < HALF_LENGTH - 20) {
            moveX += 2; // Run forward
            // Slight movement toward center of goal
            moveY += att.y > 0 ? -0.5 : 0.5;
        }

        // 4. Width - wingers should stay wide
        if (Math.abs(att.y) > 15) {
            // If winger, maintain width
            const targetY = att.y > 0 ? Math.min(28, att.y + 1) : Math.max(-28, att.y - 1);
            moveY += (targetY - att.y) * 0.3;
        }

        // 5. Don't bunch up with teammates
        for (const other of state.attackers) {
            if (other.id === att.id) continue;
            const d = dist(att, other);
            if (d < 8) {
                const awayX = att.x - other.x;
                const awayY = att.y - other.y;
                const awayDist = Math.sqrt(awayX * awayX + awayY * awayY);
                if (awayDist > 0.1) {
                    moveX += (awayX / awayDist) * 0.5;
                    moveY += (awayY / awayDist) * 0.5;
                }
            }
        }

        // Apply movement with limits
        const maxMove = 3;
        const moveDist = Math.sqrt(moveX * moveX + moveY * moveY);
        if (moveDist > maxMove) {
            moveX = (moveX / moveDist) * maxMove;
            moveY = (moveY / moveDist) * maxMove;
        }

        state.attackers[i].x = Math.max(-HALF_LENGTH + 5, Math.min(HALF_LENGTH - 5, att.x + moveX));
        state.attackers[i].y = Math.max(-HALF_WIDTH + 3, Math.min(HALF_WIDTH - 3, att.y + moveY));
    }
}

// Smarter defender movement
function moveDefenders(state) {
    for (let i = 0; i < state.defenders.length; i++) {
        const def = state.defenders[i];
        let moveX = 0, moveY = 0;

        // 1. Track nearest attacker (man marking)
        let nearestAtt = null;
        let nearestAttDist = Infinity;
        for (const att of state.attackers) {
            const d = dist(def, att);
            if (d < nearestAttDist) {
                nearestAttDist = d;
                nearestAtt = att;
            }
        }

        // 2. Move toward nearest attacker if they're close to ball
        if (nearestAtt) {
            const attToBall = dist(nearestAtt, state.ball);
            if (attToBall < 20) {
                const toAtt = { x: nearestAtt.x - def.x, y: nearestAtt.y - def.y };
                const d = norm(toAtt);
                if (d > 3) { // Don't get too close
                    moveX += (toAtt.x / d) * 1.5;
                    moveY += (toAtt.y / d) * 1;
                }
            }
        }

        // 3. Compress toward ball (defensive compactness)
        const toBall = { x: state.ball.x - def.x, y: state.ball.y - def.y };
        const ballDist = norm(toBall);
        if (ballDist > 15 && def.x > state.ball.x) {
            // Only move if behind the ball
            moveX += (toBall.x / ballDist) * 1;
            moveY += (toBall.y / ballDist) * 0.5;
        }

        // 4. Maintain defensive line - don't go past other defenders
        const avgDefX = state.defenders.reduce((sum, d) => sum + d.x, 0) / state.defenders.length;
        if (def.x < avgDefX - 5) {
            moveX += 0.5; // Don't get caught too deep
        }

        // 5. Cover goal - CBs should stay central
        if (Math.abs(def.y) < 15 && def.x > 25) {
            // Central defender, stay between ball and goal
            const coverY = state.ball.y * 0.3;
            moveY += (coverY - def.y) * 0.2;
        }

        // Apply movement
        const maxMove = 2.5;
        const moveDist = Math.sqrt(moveX * moveX + moveY * moveY);
        if (moveDist > maxMove) {
            moveX = (moveX / moveDist) * maxMove;
            moveY = (moveY / moveDist) * maxMove;
        }

        state.defenders[i].x = Math.max(-HALF_LENGTH + 5, Math.min(HALF_LENGTH - 3, def.x + moveX));
        state.defenders[i].y = Math.max(-HALF_WIDTH + 3, Math.min(HALF_WIDTH - 3, def.y + moveY));
    }
}

// Run full simulation
function runFullSimulation(initialState, maxSteps = 15) {
    const frames = [];
    let state = JSON.parse(JSON.stringify(initialState));

    for (let step = 0; step < maxSteps; step++) {
        const actions = findActions(state);

        if (actions.length === 0 || !state.carrierId) {
            frames.push({
                step: step + 1,
                state: JSON.parse(JSON.stringify(state)),
                actions: [],
                chosenAction: null,
                result: 'end',
                message: 'No actions available'
            });
            break;
        }

        const chosenAction = actions[0]; // Pick best action
        const { newState, result, message } = executeAction(state, chosenAction);

        frames.push({
            step: step + 1,
            state: JSON.parse(JSON.stringify(state)),
            actions,
            chosenAction,
            result,
            message
        });

        if (result === 'goal' || result === 'intercepted' || result === 'tackled' || result === 'missed') {
            // Add final frame
            frames.push({
                step: step + 2,
                state: JSON.parse(JSON.stringify(newState)),
                actions: [],
                chosenAction: null,
                result: 'end',
                message: result === 'goal' ? 'GOAL SCORED!' : 'Possession lost'
            });
            break;
        }

        state = newState;
    }

    return frames;
}

// ============================================
// UI CODE
// ============================================

const canvas = document.getElementById('pitch');
const ctx = canvas.getContext('2d');

let currentTab = 'simulation';
let currentTool = 'select';
let selectedPlayer = null;
let dragging = false;
let highlightedAction = null;

// Editor state
let editorState = {
    attackers: [],
    defenders: [],
    ball: null,
    carrierId: null
};

// Simulation state
let frames = [];
let currentFrame = 0;
let playing = false;
let playInterval = null;
let speed = 800;

// Convert pitch coords to canvas
const scaleX = canvas.width / PITCH_LENGTH;
const scaleY = canvas.height / PITCH_WIDTH;

function pitchToCanvas(x, y) {
    return { x: (x + HALF_LENGTH) * scaleX, y: (HALF_WIDTH - y) * scaleY };
}

function canvasToPitch(cx, cy) {
    return { x: cx / scaleX - HALF_LENGTH, y: HALF_WIDTH - cy / scaleY };
}

function drawPitch() {
    ctx.fillStyle = '#2d5a27';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 2;

    // Center line & circle
    const c = pitchToCanvas(0, 0);
    ctx.beginPath(); ctx.moveTo(c.x, 0); ctx.lineTo(c.x, canvas.height); ctx.stroke();
    ctx.beginPath(); ctx.arc(c.x, c.y, 9.15 * scaleX, 0, Math.PI * 2); ctx.stroke();

    // Penalty areas
    const pl = pitchToCanvas(-HALF_LENGTH, 20.15);
    ctx.strokeRect(pl.x, pl.y, 16.5 * scaleX, 40.3 * scaleY);
    const pr = pitchToCanvas(HALF_LENGTH - 16.5, 20.15);
    ctx.strokeRect(pr.x, pr.y, 16.5 * scaleX, 40.3 * scaleY);

    // Goal areas (6-yard box)
    const ga1 = pitchToCanvas(-HALF_LENGTH, 9.16);
    ctx.strokeRect(ga1.x, ga1.y, 5.5 * scaleX, 18.32 * scaleY);
    const ga2 = pitchToCanvas(HALF_LENGTH - 5.5, 9.16);
    ctx.strokeRect(ga2.x, ga2.y, 5.5 * scaleX, 18.32 * scaleY);

    // Penalty spots
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    const ps1 = pitchToCanvas(-HALF_LENGTH + 11, 0);
    ctx.beginPath(); ctx.arc(ps1.x, ps1.y, 3, 0, Math.PI * 2); ctx.fill();
    const ps2 = pitchToCanvas(HALF_LENGTH - 11, 0);
    ctx.beginPath(); ctx.arc(ps2.x, ps2.y, 3, 0, Math.PI * 2); ctx.fill();

    // GOALS - Make them very visible!
    // Left goal (defending)
    const gl = pitchToCanvas(-HALF_LENGTH, GOAL_WIDTH / 2);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.fillRect(gl.x - 4 * scaleX, gl.y, 4 * scaleX, GOAL_WIDTH * scaleY);
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3;
    ctx.strokeRect(gl.x - 4 * scaleX, gl.y, 4 * scaleX, GOAL_WIDTH * scaleY);

    // Right goal (attacking) - BRIGHT RED/ORANGE to show target
    const gr = pitchToCanvas(HALF_LENGTH, GOAL_WIDTH / 2);
    ctx.fillStyle = 'rgba(255, 100, 50, 0.6)'; // Orange glow
    ctx.fillRect(gr.x, gr.y, 4 * scaleX, GOAL_WIDTH * scaleY);
    ctx.strokeStyle = '#ff6432';
    ctx.lineWidth = 4;
    ctx.strokeRect(gr.x, gr.y, 4 * scaleX, GOAL_WIDTH * scaleY);

    // Goal posts for attacking goal
    ctx.fillStyle = '#fff';
    ctx.fillRect(gr.x, gr.y - 2, 3 * scaleX, 4); // Top post
    ctx.fillRect(gr.x, gr.y + GOAL_WIDTH * scaleY - 2, 3 * scaleX, 4); // Bottom post

    // Reset stroke style
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 2;
}

// Draw xG heatmap zones on the pitch
function drawScoringZones(state, bestPlay) {
    if (!state) return;

    const zones = findScoringZones(state);

    // Draw all zones as semi-transparent circles (heatmap effect)
    for (const zone of zones) {
        const pos = pitchToCanvas(zone.pos.x, zone.pos.y);

        // Color based on xG: red = high, yellow = medium, green = low
        const intensity = Math.min(1, zone.xG * 2);
        const r = Math.floor(255 * intensity);
        const g = Math.floor(255 * (1 - intensity * 0.5));
        const b = 50;

        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 15 + zone.xG * 20, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.2 + zone.xG * 0.3})`;
        ctx.fill();
    }

    // Highlight the best zone with a ring
    if (bestPlay && bestPlay.zone) {
        const pos = pitchToCanvas(bestPlay.zone.pos.x, bestPlay.zone.pos.y);
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 20, 0, Math.PI * 2);
        ctx.strokeStyle = '#f1c40f';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Label with xG
        ctx.fillStyle = '#f1c40f';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${(bestPlay.zone.xG * 100).toFixed(0)}%`, pos.x, pos.y - 25);
    }
}

// Draw the path to the target zone
function drawBestPath(state, bestPlay) {
    if (!bestPlay || !bestPlay.path) return;

    const path = bestPlay.path;
    const carrier = state.attackers.find(a => a.id === state.carrierId);
    if (!carrier) return;

    const from = pitchToCanvas(carrier.x, carrier.y);
    const to = pitchToCanvas(path.zone.x, path.zone.y);

    // Draw path line
    ctx.beginPath();
    ctx.moveTo(from.x, from.y);

    if (path.type === 'pass' || path.type === 'pass-then-move') {
        // Find the player receiving
        const receiver = state.attackers.find(a => a.id === path.player);
        if (receiver) {
            const recv = pitchToCanvas(receiver.x, receiver.y);
            ctx.lineTo(recv.x, recv.y);

            // If pass-then-move, show the run to zone
            if (path.type === 'pass-then-move') {
                ctx.strokeStyle = 'rgba(0, 188, 212, 0.8)';
                ctx.setLineDash([5, 5]);
                ctx.lineTo(to.x, to.y);
            }
        }
    } else if (path.type === 'dribble') {
        ctx.lineTo(to.x, to.y);
    }

    ctx.strokeStyle = path.type === 'dribble' ? 'rgba(156, 39, 176, 0.8)' : 'rgba(76, 175, 80, 0.8)';
    ctx.lineWidth = 3;
    ctx.setLineDash([8, 4]);
    ctx.stroke();
    ctx.setLineDash([]);

    // Arrow at end
    const angle = Math.atan2(to.y - from.y, to.x - from.x);
    ctx.beginPath();
    ctx.moveTo(to.x, to.y);
    ctx.lineTo(to.x - 12 * Math.cos(angle - 0.4), to.y - 12 * Math.sin(angle - 0.4));
    ctx.lineTo(to.x - 12 * Math.cos(angle + 0.4), to.y - 12 * Math.sin(angle + 0.4));
    ctx.closePath();
    ctx.fillStyle = ctx.strokeStyle;
    ctx.fill();
}

function drawPlayer(x, y, color, label, hasBall, isSelected) {
    const pos = pitchToCanvas(x, y);

    if (isSelected) {
        ctx.beginPath(); ctx.arc(pos.x, pos.y, 16, 0, Math.PI * 2);
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 3; ctx.stroke();
    }

    ctx.beginPath(); ctx.arc(pos.x, pos.y, 12, 0, Math.PI * 2);
    ctx.fillStyle = color; ctx.fill();
    ctx.strokeStyle = hasBall ? '#f1c40f' : '#fff';
    ctx.lineWidth = hasBall ? 3 : 1.5; ctx.stroke();

    ctx.fillStyle = '#fff'; ctx.font = 'bold 10px Arial';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(label, pos.x, pos.y);
}

function drawBall(x, y) {
    const pos = pitchToCanvas(x, y);
    ctx.beginPath(); ctx.arc(pos.x, pos.y, 7, 0, Math.PI * 2);
    ctx.fillStyle = '#f1c40f'; ctx.fill();
    ctx.strokeStyle = '#000'; ctx.lineWidth = 1.5; ctx.stroke();
}

function drawAction(from, to, result, isHighlighted) {
    const f = pitchToCanvas(from.x, from.y);
    const t = pitchToCanvas(to.x, to.y);

    ctx.beginPath(); ctx.moveTo(f.x, f.y); ctx.lineTo(t.x, t.y);

    if (isHighlighted) {
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 4; ctx.setLineDash([]);
    } else {
        ctx.strokeStyle = result === 'success' || result === 'goal'
            ? 'rgba(46, 204, 113, 0.8)'
            : result === null ? 'rgba(78, 204, 163, 0.5)' : 'rgba(231, 76, 60, 0.8)';
        ctx.lineWidth = 3; ctx.setLineDash([5, 5]);
    }
    ctx.stroke(); ctx.setLineDash([]);

    // Arrow head
    const angle = Math.atan2(t.y - f.y, t.x - f.x);
    ctx.beginPath(); ctx.moveTo(t.x, t.y);
    ctx.lineTo(t.x - 10 * Math.cos(angle - 0.4), t.y - 10 * Math.sin(angle - 0.4));
    ctx.lineTo(t.x - 10 * Math.cos(angle + 0.4), t.y - 10 * Math.sin(angle + 0.4));
    ctx.closePath();
    ctx.fillStyle = ctx.strokeStyle; ctx.fill();
}

let showZones = true; // Toggle for zone visualization

function render() {
    drawPitch();

    if (currentTab === 'editor') {
        // Show zones in editor too when we have enough players
        if (editorState.attackers.length > 0 && editorState.defenders.length > 0 && editorState.carrierId && showZones) {
            const plays = findBestPlay(editorState);
            const bestPlay = plays.length > 0 ? plays[0] : null;
            drawScoringZones(editorState, bestPlay);
            drawBestPath(editorState, bestPlay);
        }
        renderEditor();
        return;
    }

    if (frames.length === 0) return;

    const frame = frames[currentFrame];
    const st = frame.state;

    // Draw scoring zones and best path
    if (showZones && st.carrierId) {
        const plays = findBestPlay(st);
        const bestPlay = plays.length > 0 ? plays[0] : null;
        drawScoringZones(st, bestPlay);
        drawBestPath(st, bestPlay);
    }

    // Draw actions
    if (highlightedAction) {
        drawAction(st.ball, highlightedAction.target, null, true);
    } else if (frame.chosenAction) {
        drawAction(st.ball, frame.chosenAction.target, frame.result, false);
    }

    // Draw players
    st.defenders.forEach(d => drawPlayer(d.x, d.y, '#e74c3c', d.id.replace('D', ''), false, false));
    st.attackers.forEach(a => drawPlayer(a.x, a.y, '#3498db', a.id, a.id === st.carrierId, false));
    drawBall(st.ball.x, st.ball.y);

    updateUI(frame);
}

function renderEditor() {
    editorState.defenders.forEach((d, i) => {
        const isSel = selectedPlayer?.type === 'defender' && selectedPlayer.index === i;
        const hasBall = editorState.carrierId === d.id;
        drawPlayer(d.x, d.y, '#e74c3c', 'D' + (i + 1), hasBall, isSel);
    });

    editorState.attackers.forEach((a, i) => {
        const isSel = selectedPlayer?.type === 'attacker' && selectedPlayer.index === i;
        const hasBall = editorState.carrierId === a.id;
        drawPlayer(a.x, a.y, '#3498db', a.id, hasBall, isSel);
    });

    if (editorState.ball) drawBall(editorState.ball.x, editorState.ball.y);
}

function updateUI(frame) {
    const st = frame.state;
    document.getElementById('stepNum').textContent = frame.step;
    document.getElementById('totalSteps').textContent = frames.length;
    document.getElementById('progressBar').style.width = (currentFrame / Math.max(1, frames.length - 1) * 100) + '%';

    document.getElementById('carrier').textContent = st.carrierId || '-';
    document.getElementById('ballPos').textContent = `(${st.ball.x.toFixed(1)}, ${st.ball.y.toFixed(1)})`;

    if (frame.chosenAction) {
        document.getElementById('actionType').textContent = frame.chosenAction.type.toUpperCase();
        document.getElementById('actionTarget').textContent =
            `(${frame.chosenAction.target.x.toFixed(1)}, ${frame.chosenAction.target.y.toFixed(1)})`;
        document.getElementById('successProb').textContent = (frame.chosenAction.successProb * 100).toFixed(0) + '%';
        document.getElementById('expValue').textContent = frame.chosenAction.expectedValue.toFixed(3);
    } else {
        ['actionType', 'actionTarget', 'successProb', 'expValue'].forEach(id =>
            document.getElementById(id).textContent = '-');
    }

    const resEl = document.getElementById('result');
    resEl.textContent = frame.result || '-';
    resEl.className = frame.result === 'success' ? 'result-success' :
                      frame.result === 'goal' ? 'result-goal' : 'result-fail';
    document.getElementById('message').textContent = frame.message || '';

    document.getElementById('backBtn').disabled = currentFrame === 0;
    document.getElementById('fwdBtn').disabled = currentFrame >= frames.length - 1;

    updateActionList(frame);
}

function updateActionList(frame) {
    const list = document.getElementById('actionList');
    if (!frame.actions || frame.actions.length === 0) {
        list.innerHTML = '<div style="color: #666; font-size: 12px;">No actions</div>';
        return;
    }

    list.innerHTML = frame.actions.map((a, i) => {
        let tags = '';
        if (a.type === 'pass') {
            // ONE-TWO indicator (give and go)
            if (a.isOneTwo) {
                const oneTwoLabel = a.oneTwoXG
                    ? `1-2 → ${a.oneTwoXG}% xG`
                    : `1-2 (${a.oneTwoReturnProb}%)`;
                tags += `<span style="background:#00bcd4;color:#fff;padding:1px 4px;border-radius:3px;font-size:10px;margin-right:3px;font-weight:bold;">${oneTwoLabel}</span>`;
            }
            // CUTBACK indicator
            if (a.isCutback) {
                tags += '<span style="background:#e91e63;color:#fff;padding:1px 4px;border-radius:3px;font-size:10px;margin-right:3px;font-weight:bold;">CUTBACK</span>';
            }
            // Show receiver's shot potential if significant
            if (a.receiverXG && parseFloat(a.receiverXG) > 5) {
                tags += `<span style="background:#f1c40f;color:#1a1a2e;padding:1px 4px;border-radius:3px;font-size:10px;margin-right:3px;font-weight:bold;">RCV xG ${a.receiverXG}%</span>`;
            }
            // LOOKAHEAD: Show if pass creates a shot opportunity
            if (a.createsShot) {
                tags += `<span style="background:#9b59b6;color:#fff;padding:1px 4px;border-radius:3px;font-size:10px;margin-right:3px;">→SHOT ${a.shotXG}%</span>`;
            } else if (a.nextBestAction && !a.isOneTwo) {
                tags += `<span style="background:#555;color:#fff;padding:1px 4px;border-radius:3px;font-size:10px;margin-right:3px;">→${a.nextBestAction}</span>`;
            }
            if (a.isFreeMan) tags += '<span style="background:#27ae60;color:#fff;padding:1px 4px;border-radius:3px;font-size:10px;margin-right:3px;">FREE</span>';
            if (a.isProgressive) tags += '<span style="background:#3498db;color:#fff;padding:1px 4px;border-radius:3px;font-size:10px;margin-right:3px;">PROG</span>';
            if (a.receiverSpace && parseFloat(a.receiverSpace) < 5) tags += '<span style="background:#e74c3c;color:#fff;padding:1px 4px;border-radius:3px;font-size:10px;">TIGHT</span>';
        }
        if (a.type === 'shot') {
            if (a.inSixYard) tags += '<span style="background:#27ae60;color:#fff;padding:1px 4px;border-radius:3px;font-size:10px;margin-right:3px;">6YD</span>';
            else if (a.inBox) tags += '<span style="background:#f39c12;color:#fff;padding:1px 4px;border-radius:3px;font-size:10px;margin-right:3px;">PEN BOX</span>';
            tags += `<span style="background:#9b59b6;color:#fff;padding:1px 4px;border-radius:3px;font-size:10px;margin-right:3px;">${a.distToGoal}m</span>`;
            tags += `<span style="background:#3498db;color:#fff;padding:1px 4px;border-radius:3px;font-size:10px;margin-right:3px;">${a.angle}°</span>`;
            if (a.defendersBlocking > 0) {
                tags += `<span style="background:#e74c3c;color:#fff;padding:1px 4px;border-radius:3px;font-size:10px;">${a.defendersBlocking} BLOCK</span>`;
            }
        }

        let info = '';
        if (a.type === 'pass') {
            info = `${a.targetPlayer} - ${(a.successProb * 100).toFixed(0)}% (${a.distance}m)`;
            if (a.interceptors > 0) {
                tags += `<span style="background:#e67e22;color:#fff;padding:1px 4px;border-radius:3px;font-size:10px;margin-right:3px;">${a.interceptors} DEF</span>`;
            }
        } else if (a.type === 'shot') {
            info = `xG: ${a.xG}% (${a.distToGoal}m, ${a.angle}° angle)`;
        } else {
            info = `${(a.successProb * 100).toFixed(0)}%`;
        }

        return `
        <div class="action-item ${a === highlightedAction ? 'selected' : ''}"
             onmouseenter="highlightAction(${i})" onmouseleave="clearHighlight()">
            <span class="action-type">${a.type}</span>
            <span class="action-value">${a.expectedValue.toFixed(3)}</span>
            <div style="color: #888; margin-top: 3px;">${info}</div>
            <div style="margin-top: 3px;">${tags}</div>
        </div>
    `}).join('');
}

function highlightAction(i) {
    if (frames.length > 0 && frames[currentFrame].actions[i]) {
        highlightedAction = frames[currentFrame].actions[i];
        render();
    }
}

function clearHighlight() { highlightedAction = null; render(); }

// Simulation controls
function stepForward() { if (currentFrame < frames.length - 1) { currentFrame++; render(); } else stopPlay(); }
function stepBack() { if (currentFrame > 0) { currentFrame--; render(); } }
function resetSim() { stopPlay(); currentFrame = 0; render(); }
function togglePlay() { playing ? stopPlay() : startPlay(); }
function startPlay() {
    playing = true;
    document.getElementById('playBtn').textContent = 'Pause';
    playInterval = setInterval(() => currentFrame < frames.length - 1 ? stepForward() : stopPlay(), speed);
}
function stopPlay() {
    playing = false;
    document.getElementById('playBtn').textContent = 'Play';
    if (playInterval) { clearInterval(playInterval); playInterval = null; }
}
function updateSpeed() { speed = 2200 - document.getElementById('speed').value; if (playing) { stopPlay(); startPlay(); } }

// Tab switching
function switchTab(tab) {
    currentTab = tab;
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    event.target.classList.add('active');
    document.querySelectorAll('.tab-content').forEach(c => c.style.display = 'none');
    document.getElementById(tab + '-tab').style.display = 'block';
    render();
}

// Editor functions
function setTool(tool) {
    currentTool = tool;
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('tool-' + tool).classList.add('active');
}

function clearPitch() {
    editorState = { attackers: [], defenders: [], ball: null, carrierId: null };
    selectedPlayer = null;
    document.getElementById('selectedInfo').style.display = 'none';
    render();
}

function loadDefault() {
    editorState = {
        attackers: [
            { id: 'GK', x: -45, y: 0 },
            { id: 'CB1', x: -30, y: -10 },
            { id: 'CB2', x: -30, y: 10 },
            { id: 'LB', x: -25, y: -25 },
            { id: 'RB', x: -25, y: 25 },
            { id: 'CM1', x: -10, y: -8 },
            { id: 'CM2', x: -10, y: 8 },
            { id: 'CAM', x: 5, y: 0 },
            { id: 'LW', x: 15, y: -18 },
            { id: 'RW', x: 15, y: 18 },
            { id: 'ST', x: 20, y: 0 }
        ],
        defenders: [
            { id: 'D_GK', x: 45, y: 0 },
            { id: 'D_CB1', x: 32, y: -8 },
            { id: 'D_CB2', x: 32, y: 8 },
            { id: 'D_LB', x: 28, y: -22 },
            { id: 'D_RB', x: 28, y: 22 },
            { id: 'D_CM1', x: 18, y: -10 },
            { id: 'D_CM2', x: 18, y: 10 },
            { id: 'D_DM', x: 22, y: 0 },
            { id: 'D_LM', x: 12, y: -15 },
            { id: 'D_RM', x: 12, y: 15 }
        ],
        ball: { x: -30, y: -10 },
        carrierId: 'CB1'
    };
    render();
}

function deleteSelected() {
    if (!selectedPlayer) return;
    if (selectedPlayer.type === 'attacker') {
        if (editorState.carrierId === editorState.attackers[selectedPlayer.index].id) editorState.carrierId = null;
        editorState.attackers.splice(selectedPlayer.index, 1);
    } else {
        editorState.defenders.splice(selectedPlayer.index, 1);
    }
    selectedPlayer = null;
    document.getElementById('selectedInfo').style.display = 'none';
    render();
}

function runSimulation() {
    if (editorState.attackers.length === 0 || !editorState.ball || !editorState.carrierId) {
        alert('Need at least one attacker with ball. Right-click a player to set as carrier.');
        return;
    }

    const initialState = {
        attackers: editorState.attackers.map(a => ({ ...a })),
        defenders: editorState.defenders.map(d => ({ ...d })),
        ball: { ...editorState.ball },
        carrierId: editorState.carrierId
    };

    frames = runFullSimulation(initialState, 15);
    currentFrame = 0;

    // Update stats
    let success = 0, fail = 0, goals = 0;
    frames.forEach(f => {
        if (f.result === 'success') success++;
        else if (f.result === 'goal') { goals++; success++; }
        else if (['intercepted', 'tackled', 'missed'].includes(f.result)) fail++;
    });
    document.getElementById('statSteps').textContent = frames.length;
    document.getElementById('statSuccess').textContent = success;
    document.getElementById('statFail').textContent = fail;
    document.getElementById('statGoals').textContent = goals;

    switchTab('simulation');
    document.querySelectorAll('.tab')[0].classList.add('active');
    render();
}

// Canvas interaction
canvas.addEventListener('mousedown', e => {
    if (currentTab !== 'editor') return;

    const rect = canvas.getBoundingClientRect();
    const pos = canvasToPitch(e.clientX - rect.left, e.clientY - rect.top);

    if (currentTool === 'select') {
        let found = null;
        editorState.attackers.forEach((a, i) => { if (dist(a, pos) < 4) found = { type: 'attacker', index: i }; });
        editorState.defenders.forEach((d, i) => { if (dist(d, pos) < 4) found = { type: 'defender', index: i }; });

        selectedPlayer = found;
        dragging = !!found;

        if (found) {
            document.getElementById('selectedInfo').style.display = 'block';
            const p = found.type === 'attacker' ? editorState.attackers[found.index] : editorState.defenders[found.index];
            document.getElementById('selId').textContent = p.id;
            document.getElementById('selPos').textContent = `(${p.x.toFixed(1)}, ${p.y.toFixed(1)})`;
        } else {
            document.getElementById('selectedInfo').style.display = 'none';
        }
    } else if (currentTool === 'attacker') {
        const id = 'A' + (editorState.attackers.length + 1);
        editorState.attackers.push({ id, x: pos.x, y: pos.y });
    } else if (currentTool === 'defender') {
        const id = 'D' + (editorState.defenders.length + 1);
        editorState.defenders.push({ id, x: pos.x, y: pos.y });
    } else if (currentTool === 'ball') {
        editorState.ball = { x: pos.x, y: pos.y };
    }
    render();
});

canvas.addEventListener('mousemove', e => {
    if (!dragging || !selectedPlayer) return;
    const rect = canvas.getBoundingClientRect();
    const pos = canvasToPitch(e.clientX - rect.left, e.clientY - rect.top);
    pos.x = Math.max(-HALF_LENGTH, Math.min(HALF_LENGTH, pos.x));
    pos.y = Math.max(-HALF_WIDTH, Math.min(HALF_WIDTH, pos.y));

    const p = selectedPlayer.type === 'attacker'
        ? editorState.attackers[selectedPlayer.index]
        : editorState.defenders[selectedPlayer.index];
    p.x = pos.x; p.y = pos.y;

    // Move ball with carrier
    if (editorState.carrierId === p.id) {
        editorState.ball = { x: pos.x, y: pos.y };
    }

    document.getElementById('selPos').textContent = `(${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})`;
    render();
});

canvas.addEventListener('mouseup', () => { dragging = false; });

canvas.addEventListener('contextmenu', e => {
    e.preventDefault();
    if (currentTab !== 'editor') return;

    const rect = canvas.getBoundingClientRect();
    const pos = canvasToPitch(e.clientX - rect.left, e.clientY - rect.top);

    // Find clicked player
    let found = null;
    editorState.attackers.forEach((a, i) => { if (dist(a, pos) < 4) found = { type: 'attacker', index: i, player: a }; });

    if (found) {
        editorState.carrierId = found.player.id;
        editorState.ball = { x: found.player.x, y: found.player.y };
        render();
    }
});

// Initialize with default setup
loadDefault();
render();
</script>
</body>
</html>
