<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decision Engine - Tactical Board</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
            padding: 20px;
            gap: 20px;
        }

        /* Pitch area */
        .pitch-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            font-size: 1.5rem;
            color: #00d4ff;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        button {
            background: #00d4ff;
            color: #1a1a2e;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        button:hover {
            background: #00a8cc;
            transform: translateY(-1px);
        }

        button.secondary {
            background: #444;
            color: #eee;
        }

        button.secondary:hover {
            background: #555;
        }

        #pitch {
            flex: 1;
            background: #2d5a27;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        .instructions {
            font-size: 0.85rem;
            color: #888;
            text-align: center;
        }

        .coords-display {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.85rem;
            font-family: monospace;
        }

        .xg-display {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.85rem;
        }

        /* Analysis panel */
        .analysis-panel {
            width: 350px;
            background: #16213e;
            border-radius: 10px;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel-section {
            background: #1a1a2e;
            border-radius: 8px;
            padding: 15px;
        }

        .panel-section h3 {
            color: #00d4ff;
            font-size: 0.9rem;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #333;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            font-weight: 600;
        }

        .stat-value.positive { color: #4ade80; }
        .stat-value.negative { color: #f87171; }
        .stat-value.neutral { color: #fbbf24; }

        /* Gaps list */
        .gap-item {
            background: #222;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 8px;
            border-left: 3px solid #fbbf24;
        }

        .gap-item.exploitable {
            border-left-color: #4ade80;
        }

        .gap-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .gap-title {
            font-weight: 600;
        }

        .gap-badge {
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 3px;
            background: #4ade80;
            color: #000;
        }

        .gap-badge.covered {
            background: #666;
            color: #fff;
        }

        .gap-details {
            font-size: 0.85rem;
            color: #888;
        }

        /* Options list */
        .option-item {
            background: #222;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .option-item:hover {
            background: #2a2a3a;
        }

        .option-item.best {
            border: 2px solid #00d4ff;
        }

        .option-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .option-type {
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.85rem;
        }

        .option-rec {
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .option-rec.HIGH_VALUE { background: #4ade80; color: #000; }
        .option-rec.SAFE { background: #00d4ff; color: #000; }
        .option-rec.MODERATE { background: #fbbf24; color: #000; }
        .option-rec.LOW_VALUE { background: #f97316; color: #000; }
        .option-rec.AVOID { background: #f87171; color: #000; }

        .option-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            font-size: 0.8rem;
            color: #888;
        }

        /* Best option highlight */
        .best-option {
            background: linear-gradient(135deg, #16213e, #1a1a2e);
            border: 2px solid #00d4ff;
        }

        .best-option h3 {
            color: #4ade80;
        }

        /* Toggle switches */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
        }

        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #444;
            transition: 0.3s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #00d4ff;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        /* Loading state */
        .loading {
            text-align: center;
            padding: 20px;
            color: #888;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="pitch-container">
            <div class="header">
                <h1>Decision Engine</h1>
                <div class="controls">
                    <button onclick="runAnalysis()">Analyze</button>
                    <button class="secondary" onclick="resetScenario()">Reset</button>
                </div>
            </div>
            <div id="pitch">
                <canvas id="canvas"></canvas>
                <div class="coords-display" id="coordsDisplay">x: 0 yds, y: 0 yds</div>
                <div class="xg-display" id="xgDisplay">xG: 0.000</div>
            </div>
            <p class="instructions">Click to move ball | Drag players to reposition | Toggle layers on right panel</p>
        </div>

        <div class="analysis-panel">
            <div class="panel-section">
                <h3>Display Options</h3>
                <div class="toggle-row">
                    <span>Show xG Zones</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="showXgZones" onchange="render()">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-row">
                    <span>Show Coordinates</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="showCoords" checked onchange="render()">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-row">
                    <span>Show Gaps</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="showGaps" checked onchange="render()">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-row">
                    <span>Show Best Option</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="showBestOption" checked onchange="render()">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-row">
                    <span>Show All Options</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="showAllOptions" onchange="render()">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>

            <div class="panel-section">
                <h3>Summary</h3>
                <div class="stat-row">
                    <span class="stat-label">Ball Position</span>
                    <span class="stat-value" id="ballPos">-</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Total Options</span>
                    <span class="stat-value" id="totalOptions">-</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">High Value</span>
                    <span class="stat-value positive" id="highValueOptions">-</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Safe Options</span>
                    <span class="stat-value neutral" id="safeOptions">-</span>
                </div>
            </div>

            <div class="panel-section best-option" id="bestOptionPanel" style="display: none;">
                <h3>Recommended Action</h3>
                <div id="bestOptionContent"></div>
            </div>

            <div class="panel-section">
                <h3>Defensive Gaps</h3>
                <div id="gapsList">
                    <div class="loading">Click "Analyze" to detect gaps</div>
                </div>
            </div>

            <div class="panel-section">
                <h3>Top Options</h3>
                <div id="optionsList">
                    <div class="loading">Click "Analyze" to see options</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Pitch dimensions (yards)
        const PITCH_LENGTH = 120;
        const PITCH_WIDTH = 75;
        const PADDING = 10;

        // State
        let state = { players: [], ball: { x: 0, y: 0 } };
        let analysis = null;
        let xgZones = null;
        let canvas, ctx;
        let draggingPlayer = null;
        let scale = 1;
        let offsetX = 0, offsetY = 0;

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('click', onClick);

            loadState();
            loadXgZones();
        });

        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;

            // Calculate scale to fit pitch
            const scaleX = (canvas.width - PADDING * 2) / PITCH_LENGTH;
            const scaleY = (canvas.height - PADDING * 2) / PITCH_WIDTH;
            scale = Math.min(scaleX, scaleY);

            offsetX = (canvas.width - PITCH_LENGTH * scale) / 2;
            offsetY = (canvas.height - PITCH_WIDTH * scale) / 2;

            render();
        }

        // Coordinate conversion
        function pitchToCanvas(x, y) {
            return {
                x: offsetX + (x + PITCH_LENGTH / 2) * scale,
                y: offsetY + (PITCH_WIDTH / 2 - y) * scale
            };
        }

        function canvasToPitch(cx, cy) {
            return {
                x: (cx - offsetX) / scale - PITCH_LENGTH / 2,
                y: PITCH_WIDTH / 2 - (cy - offsetY) / scale
            };
        }

        // Load state from server
        async function loadState() {
            try {
                const res = await fetch('/api/state');
                state = await res.json();
                render();
            } catch (e) {
                console.error('Failed to load state:', e);
            }
        }

        // Load xG zones
        async function loadXgZones() {
            try {
                const res = await fetch('/api/xg_zones');
                xgZones = await res.json();
                render();
            } catch (e) {
                console.error('Failed to load xG zones:', e);
            }
        }

        // Get xG at position (interpolate from zones)
        function getXgAtPosition(x, y) {
            if (!xgZones) return 0;

            // Find closest zone
            let closest = null;
            let minDist = Infinity;

            for (const zone of xgZones.zones) {
                const dist = Math.sqrt((zone.x - x)**2 + (zone.y - y)**2);
                if (dist < minDist) {
                    minDist = dist;
                    closest = zone;
                }
            }

            return closest ? closest.xg : 0;
        }

        // Run analysis
        async function runAnalysis() {
            try {
                const res = await fetch('/api/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        ball_x: state.ball.x,
                        ball_y: state.ball.y,
                    })
                });
                analysis = await res.json();
                updateAnalysisPanel();
                render();
            } catch (e) {
                console.error('Analysis failed:', e);
            }
        }

        // Reset scenario
        async function resetScenario() {
            await fetch('/api/reset', { method: 'POST' });
            analysis = null;
            await loadState();
            updateAnalysisPanel();
        }

        // Update analysis panel
        function updateAnalysisPanel() {
            document.getElementById('ballPos').textContent =
                `(${state.ball.x.toFixed(1)}, ${state.ball.y.toFixed(1)})`;

            if (!analysis) {
                document.getElementById('totalOptions').textContent = '-';
                document.getElementById('highValueOptions').textContent = '-';
                document.getElementById('safeOptions').textContent = '-';
                document.getElementById('gapsList').innerHTML = '<div class="loading">Click "Analyze" to detect gaps</div>';
                document.getElementById('optionsList').innerHTML = '<div class="loading">Click "Analyze" to see options</div>';
                document.getElementById('bestOptionPanel').style.display = 'none';
                return;
            }

            document.getElementById('totalOptions').textContent = analysis.total_options;
            document.getElementById('highValueOptions').textContent = analysis.high_value_options;
            document.getElementById('safeOptions').textContent = analysis.safe_options;

            // Gaps
            let gapsHtml = '';
            analysis.gaps.slice(0, 5).forEach((gap, i) => {
                const expClass = gap.exploitable ? 'exploitable' : '';
                const badgeClass = gap.exploitable ? '' : 'covered';
                const badgeText = gap.exploitable ? 'EXPLOITABLE' : 'COVERED';
                gapsHtml += `
                    <div class="gap-item ${expClass}">
                        <div class="gap-header">
                            <span class="gap-title">Gap ${i + 1}</span>
                            <span class="gap-badge ${badgeClass}">${badgeText}</span>
                        </div>
                        <div class="gap-details">
                            Size: ${gap.size.toFixed(0)} yds |
                            Close: ${gap.time_to_close.toFixed(1)}s |
                            xG: ${gap.xg.toFixed(3)}
                        </div>
                    </div>
                `;
            });
            document.getElementById('gapsList').innerHTML = gapsHtml || '<div class="loading">No gaps detected</div>';

            // Options
            let optionsHtml = '';
            analysis.options.slice(0, 8).forEach((opt, i) => {
                const isBest = analysis.best_option &&
                    opt.target_x === analysis.best_option.target_x &&
                    opt.target_y === analysis.best_option.target_y;

                // Format action label
                let actionLabel = opt.action.toUpperCase();
                if (opt.target_player) {
                    actionLabel += ` ‚Üí #${opt.target_player}`;
                } else if (opt.action === 'shoot') {
                    actionLabel = 'üéØ SHOOT';
                } else if (opt.action === 'dribble') {
                    actionLabel = 'üèÉ DRIBBLE';
                } else if (opt.action === 'through_ball') {
                    actionLabel = '‚ö° THROUGH BALL';
                }

                // Extra info for passes
                let extraInfo = '';
                if (opt.action === 'pass' && opt.receiver_pressure !== undefined) {
                    const pressureLabel = opt.receiver_pressure > 0.6 ? 'HIGH' :
                                          opt.receiver_pressure > 0.3 ? 'MED' : 'LOW';
                    const facingLabel = opt.receiver_facing_goal ? '‚Üí' : '‚Üê';
                    extraInfo = `<span>Pressure: ${pressureLabel} ${facingLabel}</span>`;
                } else if (opt.action === 'shoot') {
                    extraInfo = `<span>Block: ${(opt.intercept_prob * 100).toFixed(0)}%</span>`;
                }

                optionsHtml += `
                    <div class="option-item ${isBest ? 'best' : ''}" onclick="highlightOption(${i})">
                        <div class="option-header">
                            <span class="option-type">${actionLabel}</span>
                            <span class="option-rec ${opt.recommendation}">${opt.recommendation}</span>
                        </div>
                        <div class="option-stats">
                            <span>Success: ${(opt.success_prob * 100).toFixed(0)}%</span>
                            <span>xG: ${opt.action === 'shoot' ? opt.xg_target.toFixed(3) : (opt.xg_gain >= 0 ? '+' : '') + opt.xg_gain.toFixed(3)}</span>
                            ${extraInfo}
                            <span>EV: ${opt.ev >= 0 ? '+' : ''}${opt.ev.toFixed(4)}</span>
                        </div>
                    </div>
                `;
            });
            document.getElementById('optionsList').innerHTML = optionsHtml || '<div class="loading">No options available</div>';

            // Best option
            if (analysis.best_option) {
                const opt = analysis.best_option;
                document.getElementById('bestOptionPanel').style.display = 'block';
                document.getElementById('bestOptionContent').innerHTML = `
                    <div class="stat-row">
                        <span class="stat-label">Action</span>
                        <span class="stat-value">${opt.action.toUpperCase()}</span>
                    </div>
                    ${opt.target_player ? `
                    <div class="stat-row">
                        <span class="stat-label">Target</span>
                        <span class="stat-value">Player #${opt.target_player}</span>
                    </div>
                    ` : ''}
                    <div class="stat-row">
                        <span class="stat-label">Success</span>
                        <span class="stat-value">${(opt.success_prob * 100).toFixed(0)}%</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Expected Value</span>
                        <span class="stat-value ${opt.ev >= 0 ? 'positive' : 'negative'}">${opt.ev >= 0 ? '+' : ''}${opt.ev.toFixed(4)}</span>
                    </div>
                `;
            } else {
                document.getElementById('bestOptionPanel').style.display = 'none';
            }
        }

        // Render pitch
        function render() {
            if (!ctx) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw pitch
            drawPitch();

            // Draw xG zones if enabled
            if (document.getElementById('showXgZones').checked && xgZones) {
                drawXgZones();
            }

            // Draw coordinate grid if enabled
            if (document.getElementById('showCoords').checked) {
                drawCoordinateGrid();
            }

            // Draw gaps if enabled
            if (document.getElementById('showGaps').checked && analysis) {
                drawGaps();
            }

            // Draw options if enabled
            if (document.getElementById('showAllOptions').checked && analysis) {
                drawAllOptions();
            }

            // Draw best option if enabled
            if (document.getElementById('showBestOption').checked && analysis && analysis.best_option) {
                drawBestOption();
            }

            // Draw players
            drawPlayers();

            // Draw ball
            drawBall();
        }

        function drawXgZones() {
            if (!xgZones) return;

            for (const zone of xgZones.zones) {
                const pos = pitchToCanvas(zone.x, zone.y);
                const size = zone.width * scale;

                // Color gradient: purple (low) -> blue -> cyan -> yellow -> red (high)
                const xg = zone.xg;
                let r, g, b;

                if (xg < 0.02) {
                    // Very low - dark purple
                    r = 60; g = 20; b = 80;
                } else if (xg < 0.05) {
                    // Low - blue
                    r = 30; g = 60; b = 200;
                } else if (xg < 0.10) {
                    // Medium-low - cyan
                    r = 0; g = 180; b = 220;
                } else if (xg < 0.15) {
                    // Medium - yellow
                    r = 255; g = 220; b = 0;
                } else if (xg < 0.25) {
                    // Medium-high - orange
                    r = 255; g = 140; b = 0;
                } else {
                    // High - bright red
                    r = 255; g = 40; b = 40;
                }

                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
                ctx.fillRect(pos.x - size/2, pos.y - size/2, size, size);
            }
        }

        function drawCoordinateGrid() {
            ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            ctx.lineWidth = 1;
            ctx.font = '10px monospace';
            ctx.fillStyle = 'rgba(255,255,255,0.5)';

            // Vertical lines every 10 yards
            for (let x = -60; x <= 60; x += 10) {
                const pos = pitchToCanvas(x, 0);
                const top = pitchToCanvas(x, PITCH_WIDTH/2);
                const bottom = pitchToCanvas(x, -PITCH_WIDTH/2);

                ctx.beginPath();
                ctx.moveTo(top.x, top.y);
                ctx.lineTo(bottom.x, bottom.y);
                ctx.stroke();

                // Label
                ctx.textAlign = 'center';
                ctx.fillText(`${x}`, pos.x, bottom.y + 12);
            }

            // Horizontal lines every 10 yards
            for (let y = -35; y <= 35; y += 10) {
                const pos = pitchToCanvas(0, y);
                const left = pitchToCanvas(-PITCH_LENGTH/2, y);
                const right = pitchToCanvas(PITCH_LENGTH/2, y);

                ctx.beginPath();
                ctx.moveTo(left.x, left.y);
                ctx.lineTo(right.x, right.y);
                ctx.stroke();

                // Label
                ctx.textAlign = 'left';
                ctx.fillText(`${y}`, left.x - 20, pos.y + 3);
            }
        }

        function drawPitch() {
            const tl = pitchToCanvas(-PITCH_LENGTH/2, PITCH_WIDTH/2);
            const br = pitchToCanvas(PITCH_LENGTH/2, -PITCH_WIDTH/2);

            // Pitch background
            ctx.fillStyle = '#2d5a27';
            ctx.fillRect(tl.x, tl.y, br.x - tl.x, br.y - tl.y);

            ctx.strokeStyle = 'rgba(255,255,255,0.7)';
            ctx.lineWidth = 2;

            // Outline
            ctx.strokeRect(tl.x, tl.y, br.x - tl.x, br.y - tl.y);

            // Center line
            const center = pitchToCanvas(0, 0);
            ctx.beginPath();
            ctx.moveTo(center.x, tl.y);
            ctx.lineTo(center.x, br.y);
            ctx.stroke();

            // Center circle (10 yards radius)
            ctx.beginPath();
            ctx.arc(center.x, center.y, 10 * scale, 0, Math.PI * 2);
            ctx.stroke();

            // Penalty areas (44 yards wide, 18 yards deep)
            const boxWidth = 44, boxDepth = 18;

            // Left box
            const lb = pitchToCanvas(-PITCH_LENGTH/2 + boxDepth, boxWidth/2);
            const lbSize = { w: boxDepth * scale, h: boxWidth * scale };
            ctx.strokeRect(tl.x, lb.y, lbSize.w, lbSize.h);

            // Right box
            const rb = pitchToCanvas(PITCH_LENGTH/2 - boxDepth, boxWidth/2);
            ctx.strokeRect(rb.x, rb.y, lbSize.w, lbSize.h);

            // 6-yard boxes (20 yards wide, 6 yards deep)
            const smallBoxWidth = 20, smallBoxDepth = 6;
            const sbSize = { w: smallBoxDepth * scale, h: smallBoxWidth * scale };

            // Left 6-yard box
            const lsb = pitchToCanvas(-PITCH_LENGTH/2 + smallBoxDepth, smallBoxWidth/2);
            ctx.strokeRect(tl.x, lsb.y, sbSize.w, sbSize.h);

            // Right 6-yard box
            const rsb = pitchToCanvas(PITCH_LENGTH/2 - smallBoxDepth, smallBoxWidth/2);
            ctx.strokeRect(rsb.x, rsb.y, sbSize.w, sbSize.h);

            // Goals (8 yards wide)
            ctx.lineWidth = 3;
            const goalWidth = 8;
            const gl = pitchToCanvas(-PITCH_LENGTH/2, goalWidth/2);
            const gr = pitchToCanvas(PITCH_LENGTH/2, goalWidth/2);
            ctx.strokeStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(gl.x - 5, gl.y);
            ctx.lineTo(gl.x - 5, gl.y + goalWidth * scale);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(gr.x + 5, gr.y);
            ctx.lineTo(gr.x + 5, gr.y + goalWidth * scale);
            ctx.stroke();
        }

        function drawPlayers() {
            state.players.forEach(p => {
                const pos = pitchToCanvas(p.x, p.y);
                const isGK = p.id === 1;  // Player #1 is goalkeeper
                const radius = isGK ? 14 : 12;

                // Player circle
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);

                // Goalkeeper has different color
                if (isGK) {
                    ctx.fillStyle = p.team === 0 ? '#fbbf24' : '#a855f7';  // Yellow/Purple for GKs
                } else {
                    ctx.fillStyle = p.team === 0 ? '#3b82f6' : '#ef4444';  // Blue/Red for outfield
                }
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = isGK ? 3 : 2;
                ctx.stroke();

                // Jersey number
                ctx.fillStyle = isGK ? '#000' : '#fff';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(p.id.toString(), pos.x, pos.y);
            });
        }

        function drawBall() {
            const pos = pitchToCanvas(state.ball.x, state.ball.y);

            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawGaps() {
            analysis.gaps.forEach(gap => {
                const pos = pitchToCanvas(gap.x, gap.y);
                const radius = (gap.size / 2) * scale;

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = gap.exploitable ? 'rgba(74, 222, 128, 0.3)' : 'rgba(251, 191, 36, 0.2)';
                ctx.fill();
                ctx.strokeStyle = gap.exploitable ? '#4ade80' : '#fbbf24';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            });
        }

        function drawBestOption() {
            const opt = analysis.best_option;
            const from = pitchToCanvas(state.ball.x, state.ball.y);
            const to = pitchToCanvas(opt.target_x, opt.target_y);

            // Different colors for different actions
            const actionColors = {
                'shoot': '#ff4444',
                'dribble': '#44ff44',
                'pass': '#00d4ff',
                'through_ball': '#fbbf24'
            };
            const color = actionColors[opt.action] || '#00d4ff';

            // For shooting, draw toward goal with special style
            if (opt.action === 'shoot') {
                // Draw shot line
                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);
                ctx.strokeStyle = color;
                ctx.lineWidth = 4;
                ctx.setLineDash([10, 5]);
                ctx.stroke();
                ctx.setLineDash([]);

                // Goal target circle
                ctx.beginPath();
                ctx.arc(to.x, to.y, 15, 0, Math.PI * 2);
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.stroke();

                // xG label
                ctx.fillStyle = color;
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`SHOOT xG: ${(opt.success_prob * 100).toFixed(0)}%`, (from.x + to.x) / 2, (from.y + to.y) / 2 - 15);
            }
            // For dribbling, draw dashed path
            else if (opt.action === 'dribble') {
                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);

                // Target circle
                ctx.beginPath();
                ctx.arc(to.x, to.y, 8, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.5;
                ctx.fill();
                ctx.globalAlpha = 1;

                // Label
                ctx.fillStyle = color;
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`DRIBBLE ${(opt.success_prob * 100).toFixed(0)}%`, (from.x + to.x) / 2, (from.y + to.y) / 2 - 10);
            }
            // Standard pass/through ball
            else {
                // Arrow
                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.stroke();

                // Arrowhead
                const angle = Math.atan2(to.y - from.y, to.x - from.x);
                const headLen = 15;
                ctx.beginPath();
                ctx.moveTo(to.x, to.y);
                ctx.lineTo(to.x - headLen * Math.cos(angle - Math.PI/6), to.y - headLen * Math.sin(angle - Math.PI/6));
                ctx.lineTo(to.x - headLen * Math.cos(angle + Math.PI/6), to.y - headLen * Math.sin(angle + Math.PI/6));
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();

                // Label
                const mid = { x: (from.x + to.x) / 2, y: (from.y + to.y) / 2 };
                ctx.fillStyle = color;
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                const actionLabel = opt.action === 'through_ball' ? 'THRU' : 'PASS';
                ctx.fillText(`${actionLabel} ${(opt.success_prob * 100).toFixed(0)}%`, mid.x, mid.y - 10);
            }
        }

        function drawAllOptions() {
            analysis.options.slice(0, 8).forEach((opt, i) => {
                const from = pitchToCanvas(state.ball.x, state.ball.y);
                const to = pitchToCanvas(opt.target_x, opt.target_y);

                const colors = {
                    'HIGH_VALUE': '#4ade80',
                    'SAFE': '#00d4ff',
                    'MODERATE': '#fbbf24',
                    'LOW_VALUE': '#f97316',
                    'AVOID': '#f87171'
                };
                const color = colors[opt.recommendation] || '#888';

                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;

                // Different line style for different actions
                if (opt.action === 'shoot') {
                    ctx.setLineDash([8, 4]);
                    ctx.lineWidth = 3;
                } else if (opt.action === 'dribble') {
                    ctx.setLineDash([4, 4]);
                } else if (opt.action === 'through_ball') {
                    ctx.setLineDash([12, 4]);
                } else {
                    ctx.setLineDash([]);
                }

                ctx.stroke();
                ctx.setLineDash([]);
                ctx.globalAlpha = 1;

                // Small target dot
                ctx.beginPath();
                ctx.arc(to.x, to.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.6;
                ctx.fill();
                ctx.globalAlpha = 1;
            });
        }

        // Mouse handling
        function onClick(e) {
            const rect = canvas.getBoundingClientRect();
            const cx = e.clientX - rect.left;
            const cy = e.clientY - rect.top;
            const pitch = canvasToPitch(cx, cy);

            // Check bounds
            if (Math.abs(pitch.x) <= PITCH_LENGTH/2 && Math.abs(pitch.y) <= PITCH_WIDTH/2) {
                // Move ball
                state.ball.x = pitch.x;
                state.ball.y = pitch.y;

                fetch('/api/move_ball', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ x: pitch.x, y: pitch.y })
                });

                render();
                runAnalysis();
            }
        }

        function onMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const cx = e.clientX - rect.left;
            const cy = e.clientY - rect.top;

            // Check if clicking on a player
            state.players.forEach(p => {
                const pos = pitchToCanvas(p.x, p.y);
                const dist = Math.sqrt((cx - pos.x)**2 + (cy - pos.y)**2);
                if (dist < 15) {
                    draggingPlayer = p;
                    e.preventDefault();
                }
            });
        }

        function onMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const cx = e.clientX - rect.left;
            const cy = e.clientY - rect.top;
            const pitch = canvasToPitch(cx, cy);

            // Update coordinate display
            if (Math.abs(pitch.x) <= PITCH_LENGTH/2 + 5 && Math.abs(pitch.y) <= PITCH_WIDTH/2 + 5) {
                document.getElementById('coordsDisplay').textContent =
                    `x: ${pitch.x.toFixed(0)} yds, y: ${pitch.y.toFixed(0)} yds`;

                // Update xG display
                const xg = getXgAtPosition(pitch.x, pitch.y);
                document.getElementById('xgDisplay').textContent = `xG: ${xg.toFixed(3)}`;
            }

            if (!draggingPlayer) return;

            // Clamp to pitch
            pitch.x = Math.max(-PITCH_LENGTH/2, Math.min(PITCH_LENGTH/2, pitch.x));
            pitch.y = Math.max(-PITCH_WIDTH/2, Math.min(PITCH_WIDTH/2, pitch.y));

            draggingPlayer.x = pitch.x;
            draggingPlayer.y = pitch.y;
            render();
        }

        function onMouseUp(e) {
            if (draggingPlayer) {
                fetch('/api/move_player', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        player_id: draggingPlayer.id,
                        team: draggingPlayer.team,
                        x: draggingPlayer.x,
                        y: draggingPlayer.y
                    })
                }).then(() => runAnalysis());

                draggingPlayer = null;
            }
        }

        function highlightOption(index) {
            // Could add highlighting logic here
            console.log('Highlight option', index);
        }
    </script>
</body>
</html>
